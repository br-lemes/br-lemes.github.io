<!doctype linuxdoc system>


<ARTICLE>


<TITLE>De Quando é Ligado até o Bash
<AUTHOR>Greg O'Keefe, <tt>gcokeefe@postoffice.utas.edu.au</tt>
<DATE>v0.9a, Novembro 2000

<ABSTRACT>
<!--
This is a brief description of what happens in a Linux system, from
the time that you turn on the power, to the time that you log in and
get a bash prompt. Understanding this will be helpful when you need to
solve problems or configure your system.
-->
Esta é uma breve descrição do que acontece num sistema Linux, de
quando é ligado até o momento em que você se identifica e obtém uma
linha de comandos do bash. Entender isso lhe será útil quando precisar
resolver problemas ou configurar seu sistema.
</ABSTRACT>



<TOC>



<SECT>Introdução
<P>
<!--
I find it frustrating that many things happen inside my Linux machine
that I do not understand. If, like me, you want to really understand
your system rather than just knowing how to use it, this document
should be a good place to start. This kind of background knowledge is
also needed if you want to be a top notch Linux problem solver.
-->
Acho frustrante que muitas coisas acontecem em minha máquina Linux que
não entendo. Se você, como eu, também quer realmente entender seu
sistema e não apenas saber como usá-lo, este documento é um bom
começo. Esse tipo de conhecimento também é necessário se você quer se
tornar um solucionador de problemas em Linux de primeira.

<P>
<!--
I assume that you have a working Linux box, and understand some basic
things about Unix and PC hardware. If not, an excellent place to start
learning is Eric S. Raymond's 
<URL
URL="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html"
NAME ="The Unix and Internet Fundamentals HOWTO" >
It is short, very readable and covers all the basics.
-->
Presumo que você tenha uma máquina Linux funcionando, e entende algumas
coisas básicas sobre Unix e hardware de PC. Se não, um excelente ponto
de partida é o 
<URL
URL="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html"
NAME ="The Unix and Internet Fundamentals HOWTO" > de Eric
S. Raymond. É curto, fácil de ler e trata de todos os temas básicos.

<P>
<!--
The main thread in this document is how Linux starts itself up. But it
also tries to be a more comprehensive learning resource. I have
included exercises in each section. If you actually do some of these,
you will learn much more than you could by just reading.
-->
O principal tema deste documento é como o Linux se inicializa. Mas
este também tenta ser um recurso de aprendizado mais abrangente. Eu
inclui exercícios em cada seção. Se você fizer alguns destes, irá
aprender muito mais que simplesmente lendo.

<P>
<!--
I hope some readers will undertake the best Linux learning exercise
that I know of, which is building a system from source
code. Giambattista Vico, an Italian philosopher (1668-1744) said
``verum ipsum factum'', which means ``understanding arises through
making''. Thanks to Alex (see <REF ID="acknowledge"
NAME="Acknowledgements">) for this quote.
-->
Espero que alguns leitores façam o melhor exercício para aprender
Linux que conheço, que é construir um sistema a partir do código
fonte. Giambattista Vico, um filósofo Italiano (1668-1744) disse
``verum ipsum factum'', que significa ``o conhecimento vem pela
prática''. Obrigado ao Alex (ver <REF ID="acknowledge"
NAME="Agradecimentos">) por esta citação.

<P>
<!--
If you want to ``roll your own'', you should also see Gerard Beekmans'
<URL URL="http://www.linuxfromscratch.org" NAME="Linux From Scratch
HOWTO"> (LFS). LFS has detailed instructions on building a complete
useable system from source code. On the LFS website, you will also
find a mailing list for people building systems this way. The
instructions that used to be part of this document are now in a
separate document ``Building a Minimal Linux System from Source
Code'', and can be found at
<URL URL="http://www.netspace.net.au/~gok/power2bash/" NAME="From
PowerUp to Bash Prompt home page">. They explain how to build a
``toy'' system, purely as a learning exercise.
-->
Se você quer por a mão na massa, veja também o <URL
URL="http://www.linuxfromscratch.org" NAME="Linux From Scratch HOWTO">
(LFS) de Gerard Beekman. O LFS tem instruções detalhadas para
construir um sistema usável completo a partir do código fonte. No
sítio do LFS você também vai encontrar uma lista de discussões para
pessoas que estão construindo sistemas dessa forma. As instruções que
faziam parte deste documento agora estão em um documento separado,
``Building a Minimal Linux System from Source Code'', e pode ser
encontrado em <URL URL="http://www.netspace.net.au/~gok/power2bash/"
NAME="From PowerUp to Bash Prompt home page">. Elas indicam como
construir um sistema experimental, como um mero exercício de
aprendizagem.

<P>
<!--
Packages are presented in the order in which they appear in the system
startup process. This means that if you install the packages in this
order you can reboot after each installation, and see the system get a
little closer to giving you a bash prompt each time. There is a
reassuring sense of progress in this.
-->
Os pacotes são apresentados na ordem em que eles aparecem no processo
de inicialização do sistema. Isso significa que se você instalar os
pacotes nesta ordem poderá reiniciar após cada instalação e ver o
sistema ir tomando forma, até te fornecer a linha de comandos do
bash. Há uma forte sensação de progresso.

<P>
<!--
I recommend that you first read the main text of each section,
skipping the exercises and references. Then decide how deep an
understanding you want to develop, and how much effort you are
prepared to put in. Then start at the beginning again, doing the
exercises and additional reading as you go.
-->
Recomendo primeiro ler o texto principal de cada seção, pulando os
exercícios e referências. Decida então até onde deseja se aprofundar
e quanto de esforço você está disposto a investir. Em seguida volte ao
início, fazendo os exercícios e as leituras adicionais conforme for
avançando.



<SECT>Hardware

<P>
<!--
When you first turn on your computer it tests itself to make sure
everything is in working order. This is called the ``Power on self
test''. Then a program called the bootstrap loader, located in the ROM
BIOS, looks for a boot sector. A boot sector is the first sector of a
disk and has a small program that can load an operating system. Boot
sectors are marked with a magic number 0xAA55 = 43603 at byte 0x1FE =
510. That's the last two bytes of the sector. This is how the hardware
can tell whether the sector is a boot sector or not.
-->
Quando você liga o computador, ele faz um teste em si mesmo para
certificar-se de que tudo está funcionando corretamente. Esse teste é
chamado de ``Power on self test''. Em seguida um programa chamado
bootstrap loader, que se encontra na ROM BIOS, procura por um setor de
inicialização. Um setor de inicialização é o primeiro setor em um
disco e tem um pequeno programa capaz de carregar um sistema
operacional. Os setores de inicialização são marcados com um número
mágico 0xAA55 = 43603 no byte 0x1FE = 510. Estes são os dois últimos
bytes do setor. É desta forma que o hardware pode saber se um setor é
um setor de inicialização ou não.

<P>
<!--
The bootstrap loader has a list of places to look for a boot
sector. My old machine looks in the primary floppy drive, then the
primary hard drive. More modern machines can also look for a boot
sector on a CD-ROM. If it finds a boot sector, it loads it into memory
and passes control to the program that loads the operating system. On
a typical Linux system, this program will be LILO's first stage boot
loader. There are many different ways of setting your system up to
boot though. See the <EM>LILO User's Guide</EM> for details. See
section <REF ID="lilo-links" NAME="LILO"> for a URL. 
-->
O bootstrap loader tem uma lista de lugares onde procurar por um setor
de inicialização. Minha máquina velha procura no drive primário de
disquete, em seguida no disco rígido primário. Máquinas mais modernas
também podem procurar por um setor de inicialização num CD-ROM. Se
encontrar um setor de inicialização, irá carregá-lo na memória e
passar o controle ao programa que carrega o sistema operacional. Num
sistema Linux típico este programa será o primeiro estágio do
carregador LILO. Existem muitas maneiras diferentes de configurar a
inicialização do seu sistema. Veja o <EM>LILO User's Guide</EM> para
mais detalhes. Na seção <REF ID="lilo-links" NAME="LILO"> há uma URL.

<P>
<!--
Obviously there is a lot more to say about what PC hardware does. But
this is not the place to say it. See one of the many good books about
PC hardware.
-->
Obviamente há muito mais pra dizer sobre o que o hardware dum PC
faz, mas este não é o lugar para isto. Veja um dos muitos bons livros
sobre hardware de PC.


<SECT1>Configuração
<P>
<!--
The machine stores some information about itself in its CMOS. This
includes what disks and RAM are in the system. The machine's BIOS
contains a program to let you modify these settings. Check the
messages on your screen as the machine is turned on to see how to
access it. On my machine, you press the delete key before it begins
loading its operating system.
-->
A máquina armazena alguma informação sobre si mesma em sua CMOS. Isto
inclui quais discos e RAM existem no sistema. A BIOS da máquina contém
um programa que permite a você modificar estas configurações. Veja a
mensagem na tela de sua máquina quando é ligada para verificar como
acessá-la. Em minha máquina se pressiona a tecla delete antes que ela
comece a carregar o sistema operacional.


<SECT1>Exercícios
<LABEL ID="hardware-ex">
<P>
<!--
A good way to learn about PC hardware is to build a machine out of
second hand parts. Get at least a 386 so you can easily run Linux on
it. It won't cost much. Ask around, someone might give you some of the
parts you need.
-->
Um bom jeito de aprender sobre o hardware do PC é montar uma máquina
com componentes de segunda mão. Use pelo menos um 386, assim você
poderá colocar o Linux para rodar facilmente. Não será muito
caro. Pergunte por aí, alguém poderia te dar algumas peças que vais
precisar.

<P>
<!--
Check out, download compile and make a boot disk for <URL
URL="http://www.netspace.net.au/~gok/resources" NAME=Unios>. (They
used to have a home page at <URL URL="http://www.unios.org">, but it
disappeared) This is just a bootable ``Hello World!'' program,
consisting of just over 100 lines of assembler code. It would be good
to see it converted to a format that the GNU assembler <TT>as</TT> can
understand.
-->
Baixe, compile e faça um disco de inicialização para o <URL
URL="http://www.netspace.net.au/~gok/resources" NAME=Unios>. (Eles
tinham uma página em <URL URL="http://www.unios.org"> mas
desapareceu). É um simples programa ``Olá mundo!'', que consiste em
pouco mais de 100 linhas de código assembly. Seria bom vê-lo
convertido a um formato que possa ser entendido pelo montador GNU
<TT>as</TT>.

<P>
<!--
There are instructions for ``rolling your own'' operating system at
<URL URL="http://www.acm.uiuc.edu/sigops/roll_your_own/" NAME="Roll
Your Own"> if you are after a <EM>real</EM> challenge.
-->
Existem instruções para criar seu próprio sistema operacional em <URL
URL="http://www.acm.uiuc.edu/sigops/roll_your_own/" NAME="Roll Your
Own"> se você quiser um desafio <EM>de verdade</EM>.

<P>
<!--
Open the boot disk image for unios with a hex editor. This image is
512 bytes long, exactly one sector. Find the magic number 0xAA55. Do
the same for the boot sector from a bootable floppy disk or your own
computer. You can use the <TT>dd</TT> command to copy it to a file:
<TT>dd if=/dev/fd0 of=boot.sector</TT>. Be <EM>very</EM> careful to
get <TT>if</TT> (input file) and <TT>of</TT> (output file) the right
way round!
-->
Abra a imagem de disco do unios com um editor hexadecimal. Esta imagem
tem 512 bytes, exatamente um setor. Encontre o número mágico
0xAA55. Faça o mesmo para o setor de inicialização dum disquete em seu
próprio computador. Você pode usar o comando <TT>dd</TT> para copiar
ele para um arquivo: <TT>dd if=/dev/fd0 of=boot.sector</TT>. Seja
<EM>muito</EM> cuidadoso escrevendo <TT>if</TT> (input file) e
<TT>of</tt> (output file) corretamente!

<P>
<!--
Check out the source code for LILO's boot loader.
-->
Veja o código fonte do carregador de sistemas LILO.


<SECT1>Mais Informações
<P>
<ITEMIZE>
<ITEM>
<!--
<URL
URL="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html"
NAME="The Unix and Internet Fundamentals HOWTO"> by Eric S. Raymond,
especially section 3, <EM>What happens when you switch on a
computer?</EM>
-->
<URL
URL="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html"
NAME="The Unix and Internet Fundamentals HOWTO"> por Eric S. Raymond,
especialmente a seção 3, <EM>What happens when you switch on a
computer?</EM>

<ITEM>
<!--
The first chapter of <EM>The LILO User's Guide</EM> gives an excellent
explanation of PC disk partitions and booting. See section <REF
ID="lilo-links" NAME="LILO"> for a URL.
-->
O primeiro capítulo do <EM>The LILO User's Guide</EM> tem uma
excelente explicação sobre as partições do disco e a inicialização do
PC. Na seção <REF ID="lilo-links" NAME="LILO"> há uma URL.

<ITEM>
<!--
<EM>The NEW Peter Norton Programmer's Guide to the IBM PC & PS/2</EM>,
by Peter Norton and Richard Wilton, Microsoft Press 1988 There is a
newer Norton book, which looks good, but I can't afford it right now!
-->
<EM>The NEW Peter Norton Programmer's Guide to the IBM PC & PS/2</EM>, 
por Peter Norton e Richard Wilton, Microsoft Press 1988. Há um livro
novo do Norton, parece bom, mas agora eu não posso pagar.

<ITEM>
<!--
One of the many books available on upgrading PC's
-->
Um dos muitos livros disponíveis sobre atualização de PCs.
</ITEMIZE>



<SECT>Lilo
<P>
<!--
When the computer loads a boot sector on a normal Linux system, what
it loads is actually a part of lilo, called the ``first stage boot
loader''. This is a tiny program who's only job in life is to load and
run the ``second stage boot loader''.
-->
Quando o computador carrega um setor de inicialização em um sistema
Linux normal, o que ele realmente carrega é uma parte do lilo chamado
``first stage boot loader'' (primeiro estágio do carregador). É um
pequeno programa que a única coisa que faz na vida é carregar e rodar
o segundo estágio.

<P>
<!--
The second stage loader gives you a prompt (if it was installed that
way) and loads the operating system you choose.
-->
O segundo estágio apresenta uma linha de comandos (se foi instalado
assim) e carrega o sistema operacional que você escolher.

<P>
<!--
When your system is up and running, and you run <TT>lilo</TT>, what
you are actually running is the ``map installer''. This reads the
configuration file <TT>/etc/lilo.conf</TT> and writes the boot
loaders, and information about the operating systems it can load, to
the hard disk.
-->
Quando seu sistema está em funcionamento e você roda <TT>lilo</TT>, o
que você está realmente rodando é um ``instalador do mapa''. Ele lê o
arquivo de configuração <TT>/etc/lilo.conf</TT> e escreve os
carregadores, assim como informações sobre os sistemas operacionais
que ele pode carregar, no disco rígido.

<P>
<!--
There are lots of different ways to set your system up to boot. What I
have just explained is the most obvious and ``normal'' way, at least
for a system who's main operating system is Linux. The Lilo Users'
Guide explains several examples of ``boot concepts''. It is worth
reading these, and trying some of them out.
-->
Existem diversas formas de configurar a inicialização de seu
sistema. O que acabo de explicar é a forma mais óbvia e ``normal'',
pelo menos em um sistema onde o principal sistema operacional é o
Linux. O Guia do Usuário do LILO explica vários exemplos de conceitos
de inicialização. Vale a pena ler e tentar alguns deles.


<SECT1>Configuração
<P>
<!--
The configuration file for lilo is <TT>/etc/lilo.conf</TT>. There is a
manual page for it: type <TT>man lilo.conf</TT> into a shell to see
it. The main thing in <TT>lilo.conf</TT> is one entry for each thing
that lilo is set up to boot. For a Linux entry, this includes where
the kernel is, and what disk partition to mount as the root
filesystem. For other operating systems, the main piece of information
is which partition to boot from.
-->
O arquivo de configuração para o lilo é <TT>/etc/lilo.conf</TT>. Há
uma página de manual para ele: digite <TT>man lilo.conf</TT> num
shell para vê-la. O principal no <TT>lilo.conf</TT> é uma entrada para
cada sistema operacional que o lilo pode inicializar. Em uma entrada
para Linux inclui onde está o kernel e que partição do disco montar
como raíz. Para outros sistemas operacionais, a informação mais
importante é a partir de qual partição inicializar.


<SECT1>Exercícios
<P>
<!--
<EM>DANGER:</EM> take care with these exercises. It is easy enough to
get something wrong and screw up your master boot record and make your
system unuseable. Make sure you have a working rescue disk, and know
how to use it to fix things up again. See below for a link to
tomsrtbt, the rescue disk I use and recommend. The best precaution is
to use a machine that doesn't matter.
-->
<EM>PERIGO:</EM> tome cuidado com estes exercícios. É bastante fácil
fazer algo errado e danificar seu MBR (master boot record - registro
mestre de inicialização) e tornar seu sistema inutilizável.
Certifique-se de ter um disco de recuperação funcionando e saber como
usá-lo para concertar a bagunça. Abaixo há um link para o tomsrtbt, o
disco de recuperação que eu uso e recomendo. A melhor precaução é usar
uma máquina sem importância.

<P>
<!--
Set up lilo on a floppy disk. It doesn't matter if there is nothing
other than a kernel on the floppy - you will get a ``kernel panic''
when the kernel is ready to load init, but at least you will know that
lilo is working.
-->
Prepare um disquete com o lilo. Não importa que não há nada além do
kernel no disquete - você verá um ``kernel panic'' quando o kernel
estiver pronto para carregar o init, mas pelo menos você saberá que o
lilo está funcionando.

<P>
<!--
If you like you can press on and see how much of a system you can get
going on the floppy. This is probably the second best Linux learning
activity around. See the Bootdisk HOWTO (url below), and tomsrtbt (url
below) for clues.
-->
Se quiser, você pode espremer para ver quanto do sistema você consegue
colocar num disquete. Esta é provavelmente a segunda melhor atividade
para aprender Linux. Veja o Bootdisk HOWTO (url abaixo) e tomsrtbt
(url abaixo) para ter uma idéia.

<P>
<!--
Get lilo to boot unios (see section <REF ID="hardware-ex"
NAME="hardware exercises"> for a URL). As an extra challenge, see if
you can do this on a floppy disk.
-->
Faça o lilo inicializar o unios (há uma URL na seção <REF
ID="hardware-ex" NAME="exercícios de hardware">). Como um desafio
extra tente fazer isto num disquete.

<P>
<!--
Make a boot-loop. Get lilo in the master boot record to boot lilo in
one of the primary partition boot sectors, and have that boot lilo in
the master boot record... Or perhaps use the master boot record and
all four primary partitions to make a five point loop. Fun!
-->
Faça um laço de inicializações. Configure o lilo no MBR para
inicializar o lilo no setor de inicialização de uma partição primária,
e este para inicializar o lilo no MBR... Ou talvez usar o MBR e todas
as quatro partições primárias, fazendo um laço de cinco
pontos. Divirta-se!

<SECT1>Mais Informações
<P>
<LABEL ID="lilo-links">
<ITEMIZE>
<ITEM>
<!--
The lilo man page.
-->
A página de manual do lilo.

<ITEM>
<!--
The Lilo package (<URL
URL="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/" NAME="lilo">),
contains the ``LILO User's Guide'' <TT>lilo-u-21.ps.gz</TT> (or a
later version). You may already have this document though. Check
<TT>/usr/doc/lilo</TT> or there abouts. The postscript version is
better than the plain text, since it contains diagrams and tables.
-->
O pacote Lilo (<URL
URL="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/" NAME="lilo">),
contém o ``LILO User's Guide''<TT>lilo-u-21.ps.gz</TT> (ou outra
versão mais recente). É provável que você já tenha este
documento. Tente em <TT>/usr/doc/lilo</TT> ou algo parecido. A versão
postscript é melhor que a de texto simples, já que contém diagramas e
tabelas.

<ITEM>
<!--
<URL URL="http://www.toms.net/rb" NAME="tomsrtbt"> the coolest single
floppy linux. Makes a great rescue disk.
-->
<URL URL="http://www.toms.net/rb" NAME="tomsrtbt"> o melhor linux em
um só disquete. Excelente como disco de recuperação.

<ITEM>
<URL URL="http://www.linuxdoc.org/HOWTO/Bootdisk-HOWTO/" NAME="The
Bootdisk HOWTO">

</ITEMIZE>



<SECT>O Kernel do Linux
<P>
<!--
The kernel does quite a lot really. I think a fair way of summing it
up is that it makes the hardware do what the programs want, fairly and
efficiently.
-->
Na verdade o kernel faz muitas coisas. Creio que uma boa forma de
resumir é que ele faz o hardware fazer o que os programas querem, de
forma clara e eficiente.

<P>
<!--
The processor can only execute one instruction at a time, but Linux
systems appear to be running lots of things simultaneously. The kernel
acheives this by switching from task to task really quickly. It makes
the best use of the processor by keeping track of which processes are
ready to go, and which ones are waiting for something like a record
from a hard disk file, or some keyboard input. This kernel task is
called scheduling.
-->
O processador pode executar apenas uma instrução de cada vez, mas os
sistemas Linux parecem fazer várias coisas simultaneamente. O kernel
consegue isto alternando de uma tarefa à outra rapidamente. Ele faz
um melhor uso do processador rastreando quais processos estão prontos
e quais estão esperando por algo como um registro num arquivo do disco
rígido ou uma entrada do teclado. Esta tarefa do kernel é chamada de
scheduling (agendamento). 

<P>
<!--
If a program isn't doing anything, then it doesn't need to be in
RAM. Even a program that is doing something, might have parts that
aren't doing anything. The address space of each process is divided
into pages. The Kernel keeps track of which pages of which processes
are being used the most. The pages that aren't used so much can be
moved out to the swap partition. When they are needed again, another
unused page can be paged out to make way for it. This is virtual
memory management.
-->
Se um programa não está fazendo nada, não precisa estar na RAM. Mesmo
um programa que está fazendo algo pode ter partes que não estão
fazendo nada. O espaço de endereçamento de cada processo está dividido
em páginas. O kernel verifica quais páginas estão sendo usadas mais
freqüentemente. As páginas que não estão sendo muito usadas podem ser
retiradas para a partição de troca (swap). Quando elas forem
necessárias novamente, pode se retirar outra página pouco usada para
desocupar-lhe espaço. Este é o gerenciamento de memória virtual.

<P>
<!--
If you have ever compiled your own Kernel, you will have noticed that
there are many many options for specific devices. The kernel contains
a lot of specific code to talk to diverse kinds of hardware, and
present it all in a nice uniform way to the application programs.
-->
Se alguma vez você já compilou seu próprio Kernel, você deve ter
notado que existem muitas opções para dispositivos específicos. O
kernel contém muito código específico para comunicar com os diversos
tipos de hardware, e apresentá-los de uma maneira uniforme aos
aplicativos.

<P>
<!--
The Kernel also manages the filesystem, interprocess communication,
and a lot of networking stuff.
-->
O Kernel também gerencia o sistema de arquivos, a comunicação entre os
processos, e um monte de coisas relacionadas à redes.

<P>
<!--
Once the kernel is loaded, the first thing it does is look for an
<TT>init</TT> program to run.
-->
Uma vez que o kernel for carregado, a primeira coisa que ele faz é
procurar por um programa <TT>init</TT> para executar.

<SECT1>Configuração
<P>
<!--
Most of the configuration of the kernel is done when you build it,
using <TT>make menuconfig</TT>, or <TT>make xconfig</TT> in
<TT>/usr/src/linux/</TT> (or wherever your Linux kernel source
is). You can reset the default video mode, root filesystem, swap
device and RAM disk size using <TT>rdev</TT>. These parameters and
more can also be passed to the kernel from lilo. You can give lilo
parameters to pass to the kernel either in lilo.conf, or at the lilo
prompt. For example if you wanted to use hda3 as your root file system
instead of hda2, you might type
-->
A maior parte da configuração do kernel é feita quando o estiver
construindo, usando <TT>make menuconfig</TT>, ou <TT>make xconfig</TT>
em <TT>/usr/src/linux/</TT> (ou onde quer que esteja o código fonte do
kernel do seu Linux). Você pode redefinir o modo de vídeo padrão, o
sistema de arquivos raíz, o dispositivo de troca (swap) e o tamanho do
disco em RAM usando <TT>rdev</TT>. Estes e outros parâmetros podem ser
passados ao kernel pelo lilo. Você pode dar ao lilo os parâmetros para
passar ao kernel tanto no lilo.conf quanto na linha de comandos do
lilo. Por exemplo, se quiser usar hda3 como seu sistema de arquivos
raíz em vez de hda2, poderia digitar:

<VERB>
	LILO: linux root=/dev/hda3
</VERB>

<P>
<!--
If you are building a system from source, you can make life a lot
simpler by creating a ``monolithic'' kernel. That is one with no
modules. Then you don't have to copy kernel modules to the target
system.
-->
Se estiver construindo um sistema a partir do código fonte, será bem
mais fácil criar um kernel ``monolítico'', ou seja, sem módulos. Assim
não irá precisar copiar os módulos para o sistema de destino.

<P>
<!--
NOTE: The <TT>System.map</TT> file is used by the kernel logger to
determine the module names generating messages. The program
<TT>top</TT> also uses this information. When you copy the kernel to
the target system, copy <TT>System.map</TT> too.
-->
NOTA: O agente de log do kernel usa o arquivo <TT>System.map</TT> para
determinar os nomes dos módulos gerando mensagens. O programa
<TT>top</TT> também usa esta informação. Quando copiar o kernel para o
sistema de destino, copie também <TT>System.map</TT>.

<SECT1>Exercícios
<P>
<!--
Think about this: <TT>/dev/hda3</TT> is a special type of file that
describes a hard disk partition. But it lives on a file system just
like all other files. The kernel wants to know which partition to
mount as the root filesystem - it doesn't have a file system yet. So
how can it read <TT>/dev/hda3</TT> to find out which partition to
mount?
-->
Pense nisto: <TT>/dev/hda3</TT> é um tipo especial de arquivo que
descreve uma partição do disco rígido. Mas ele está num sistema de
arquivos exatamente como todos os outros arquivos. O kernel quer saber
qual partição montar como sistema de arquivos raíz - ele ainda não tem
um sistema de arquivos. Então como ele pode ler <TT>/dev/hda3</TT>
para saber qual partição montar?

<P>
<!--
If you haven't already: build your own kernel. Read all the help
information for each option.
-->
Se ainda não o fez: construa seu próprio kernel. Leia toda a
informação de ajuda para cada opção.

<P>
<!--
See how small a kernel you can make that still works. You can learn a
lot by leaving the wrong things out!
-->
Tente fazer o menor kernel funcional possível. Você pode aprender
bastante quando as coisas derem errado!

<P>
<!--
Read ``The Linux Kernel'' (URL below) and as you do, find the parts of
the source code that it refers to. The book (as I write) refers to
kernel version 2.0.33, which is pretty out of date. It might be easier
to follow if you download this old version and read the source there.
Its amazing to find bits of C code called ``process'' and ``page''.
-->
Leia ``The Linux Kernel'' (URL abaixo) e veja se pode encontrar as
partes do código fonte a qual ele se refere. O livro (no momento em
que escrevo) usa a versão 2.0.33 do kernel, que está obsoleta. Será
mais fácil se baixar esta versão antiga e ler estes fontes. É
surpreendente encontrar coisas no código C chamados ``process'' e
``page''.

<P>
<!--
Hack! See if you can make it spit out some extra messages or
something.
-->
Fuce! Veja se consegue fazer ele mostrar umas mensagens extras ou
qualquer outra coisa.

<SECT1>Mais Informações
<LABEL ID="Kernel">
<P>
<ITEMIZE>
<ITEM>
<!--
<TT>/usr/src/linux/README</TT> and the contents of
<TT>/usr/src/linux/Documentation/</TT> (These may be in some other
place on your system)
-->
<TT>/usr/src/linux/README</TT> e o conteúdo de
<TT>/usr/src/linux/Documentation/</TT> (eles podem estar em algum
outro lugar em seu sistema)

<ITEM>
<URL
URL="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Kernel-HOWTO.html"
NAME="The Kernel HOWTO">

<ITEM>
<!--
The help available when you configure a kernel using <TT>make
menuconfig</TT> or <TT>make xconfig</TT>
-->
A ajuda disponível ao configurar um kernel usando <TT>make
menuconfig</TT> ou <TT>make xconfig</TT>

<ITEM>
<!--
<URL URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" NAME="The Linux
Kernel (and other LDP Guides)">
-->
<URL URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" NAME="The Linux
Kernel (e outros guias LDP)">

<ITEM>
<!--
source code, see <URL URL="http://www.netspace.net.au/~gok/power2bash"
NAME="Building a Minimal Linux System from Source Code"> for urls
-->
código fonte, veja <URL
URL="http://www.netspace.net.au/~gok/power2bash" NAME="Building a
Minimal Linux System from Source Code"> para encontrar urls

</ITEMIZE>



<SECT>A Biblioteca GNU C
<P>
<!--
The next thing that happens as your computer starts up is that init is
loaded and run. However, init, like almost all programs, uses
functions from libraries.
-->
A próxima coisa que acontece quando seu computador é inicializado é
carregar e rodar o init. Porém, o init, como quase todos programas,
usa funções de bibliotecas.

<P>
<!--
You may have seen an example C program like this:
-->
Você já deve ter visto um programa de exemplo em C como este:

<P>
<VERB>
	main() {
        	printf("Hello World!\n");
	}
</VERB>

<!--
The program contains no definition of <TT>printf</TT>, so where does
it come from? It comes from the standard C libraries, on a GNU/Linux
system, glibc. If you compile it under Visual C++, then it comes from
a Microsoft implementation of the same standard functions. There are
zillions of these standard functions, for math, string, dates/times
memory allocation and so on. Everything in Unix (including Linux) is
either written in C or has to try hard to pretend it is, so everything
uses these functions.
-->
O programa não contém a definição de <TT>printf</TT>, então de onde
ela vem? Ela vem das bibliotecas C padrão, num sistema GNU/Linux,
glibc. Se for compilado com o Visual C++, então será a implementação
da Microsoft das mesmas funções padrão. Existem zilhões destas funções
padrão, para matemática, string, data e hora, alocação de memória, e
assim por diante. Tudo no Unix (incluindo Linux) é escrito em C ou se
esforça em fingir que o é, portanto tudo usa estas funções.

<P>
<!--
If you look in <TT>/lib</TT> on your linux system you will see lots of
files called <TT>libsomething.so</TT> or <TT>libsomething.a</TT>
etc. They are libraries of these functions. Glibc is just the GNU
implementation of these functions.
-->
Se você olhar em <TT>/lib</TT> em seu sistema linux, verá arquivos
chamados <TT>libqualquercoisa.so</TT> ou <TT>libqualquercoisa.a</TT>
aos montes. São as bibliotecas destas funções. Glibc é apenas a
implementação GNU destas funções.

<P>
<!--
There are two ways programs can use these library functions. If you
<EM>statically</EM> link a program, these library functions are copied
into the executable that gets created. This is what the
<TT>libsomething.a</TT> libraries are for. If you <EM>dynamically</EM>
link a program (and this is the default), then when the program is
running and needs the library code, it is called from the
<TT>libsomething.so</TT> file.
-->
Existem duas formas pelas quais os programas podem usar estas funções
de bibliotecas. Se vincular <EM>estaticamente</EM>, estas funções de
bibliotecas serão copiadas no executável que será criado. Para isso
que servem as bibliotecas <TT>libqualquercoisa.a</TT>. Se vincular
<EM>dinamicamente</EM> (e este é o padrão), então quando estiver
rodando e precisar do código da biblioteca, ele será chamado a partir
do arquivo <TT>libqualquercoisa.so</TT>.

<P>
<!--
The command <TT>ldd</TT> is your friend when you want to work out
which libraries are needed by a particular program. For example, here
are the libraries that <TT>bash</TT> uses:
-->
O comando <TT>ldd</TT> é seu amigo quando quiser saber quais
bibliotecas são necessárias à um programa em particular. Por exemplo,
aqui estão as bibliotecas que o <TT>bash</TT> usa:

<P>
<VERB>
	[greg@Curry power2bash]$ ldd /bin/bash
        	libtermcap.so.2 => /lib/libtermcap.so.2 (0x40019000)
        	libc.so.6 => /lib/libc.so.6 (0x4001d000)
        	/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</VERB>

<SECT1>Configuração
<P>
<!--
Some of the functions in the libraries depend on where you are. For
example, in Australia we write dates as dd/mm/yy, but Americans write
mm/dd/yy. There is a program that comes with the <TT>glibc</TT>
distribution called <TT>localedef</TT> which enables you to set this
up.
-->
Algumas das funções das bibliotecas dependem de onde você está. Por
exemplo, na Austrália nós escrevemos as datas como dd/mm/aa, mas os
Americanos escrevem mm/dd/aa. Existe um programa que acompanha a
distribuição da <TT>glibc</TT> chamado <TT>localedef</TT> que te
permite definir isso.


<SECT1>Exercícios
<P>
<!--
Use <TT>ldd</TT> to find out what libraries your favourite
applications use.
-->
Use o <TT>ldd</TT> para verificar quais bibliotecas seus aplicativos
favoritos usam.

<P>
<!--
Use <TT>ldd</TT> to find out what libraries <TT>init</TT> uses.
-->
Use o <TT>ldd</TT> para verificar quais bibliotecas o <TT>init</TT>
usa.

<P>
<!--
Make a toy library, with just one or two functions in it. The program
<TT>ar</TT> is used to create them, the man page for <TT>ar</TT> might
be a good place to start investigating how this is done. Write,
compile and link a program that uses this library.
-->
Faça uma biblioteca de testes, apenas com uma ou duas funções. O
programa <TT>ar</TT> é usado para criá-las, a página de manual para o
<TT>ar</TT> pode ser um bom lugar para começar a investigar como isto
é feito. Escreva, compile e vincule um programa que use esta
biblioteca.


<SECT1>Mais Informações
<P>
<ITEMIZE>
<ITEM>
<!--
source code, see <URL URL="http://www.netspace.net.au/~gok/power2bash"
NAME="Building a Minimal Linux System from Source Code"> for urls
-->
código fonte, veja <URL
URL="http://www.netspace.net.au/~gok/power2bash" NAME="Building a
Minimal Linux System from Source Code"> para encontrar urls
</ITEMIZE>



<SECT>Init
<P>
<!--
I will only talk about the ``System V'' style of init that Linux
systems mostly use. There are alternatives. In fact, you can put any
program you like in <TT>/sbin/init</TT>, and the kernel will run it
when it has finished loading.
-->
Vou falar apenas sobre o init estilo ``System V'' que é majoritário
nos sistemas Linux. Existem alternativas. De fato, você pode pôr
qualquer programa que queira em <TT>/sbin/init</TT>, e o kernel vai
rodá-lo assim que terminar de carregar.

<P>
<!--
It is <TT>init</TT>'s job to get everthing running the way it should
be. It checks that the file systems are ok and mounts them. It starts
up ``daemons'' to log system messages, do networking, serve web pages,
listen to your mouse and so on. It also starts the getty processes
that put the login prompts on your virtual terminals.
-->
É tarefa do <TT>init</TT> pôr tudo para funcionar de forma
apropriada. Ele verifica se os sistemas de arquivos estão corretos e
os montam. Inicializa os ``daemons'' para registrar as mensagens do
sistema, redes, servir páginas web, escutar o mouse e tudo
mais. Também inicializa os processos ``getty'' que colocam as linhas
de comandos (prompt) de login em seus terminais virtuais.

<P>
<!--
There is a whole complicated story about switching ``run-levels'', but
I'm going to mostly skip that, and just talk about system start up.
-->
Há um contexto muito complicado que aborda a alternância entre níveis
de execução (run-levels), mas vou pular a maior parte disso e vou falar
apenas sobre a inicialização do sistema.

<P>
<!--
Init reads the file <TT>/etc/inittab</TT>, which tells it what to
do. Typically, the first thing it is told to do is to run an
initialisation script. The program that executes (or interprets) this
script is <TT>bash</TT>, the same program that gives you a command
prompt. In Debian systems, the initialisation script is
<TT>/etc/init.d/rcS</TT>, on Red Hat,
<TT>/etc/rc.d/rc.sysinit</TT>. This is where the filesystems get
checked and mounted, the clock set, swap space enabled, hostname gets
set etc.
-->
O init lê o arquivo <TT>/etc/inittab</TT>, que lhe diz o que
fazer. Tipicamente, a primeira coisa que lhe é instruída a fazer é
rodar o roteiro (script) de inicialização. O programa que executa (ou
interpreta) este roteiro é o <TT>bash</TT>, o mesmo programa que te
fornece a linha de comandos. Em sistemas Debian, o roteiro de
inicialização é <TT>/etc/init.d/rcS</TT>, no Red Hat é
<TT>/etc/rc.d/rc.sysinit</TT>. Este é o local onde os sistemas de
arquivos são checados e montados, o relógio é ajustado, os espaços de
troca (swap) habilitados, o nome da máquina é definido, etc.

<P>
<!--
Next, another script is called to take us into the default
run-level. This just means a set of subsystems to start up. There is a
set of directories <TT>/etc/rc.d/rc0.d</TT>, <TT>/etc/rc.d/rc1.d</TT>,
..., <TT>/etc/rc.d/rc6.d</TT> in Red Hat, or <TT>/etc/rc0.d</TT>,
<TT>/etc/rc1.d</TT>, ..., <TT>/etc/rc6.d</TT> in Debian, which
correspond to the run-levels. If we are going into runlevel 3 on a
Debian system, then the script runs all the scripts in
<TT>/etc/rc3.d</TT> that start with `S' (for start). These scripts are
really just links to scripts in another directory usually called
<TT>init.d</TT>.
-->
Depois chama outro roteiro que nos dá o nível de execução padrão, que é
apenas inicializar um conjunto de subsistemas. Existe um conjunto de
diretórios <TT>/etc/rc.d/rc0.d</TT>, <TT>/etc/rc.d/rc1.d</TT>, ...,
<TT>/etc/rc.d/rc6.d</TT> no Red Hat, ou <TT>/etc/rc0.d</TT>,
<TT>/etc/rc1.d</TT>, ..., <TT>/etc/rc6.d</TT> no Debian, que
correspondem aos níveis de execução. Se formos para o nível de
execução 3 num sistema Debian, então o roteiro roda todos os roteiros
em <TT>/etc/rc3.d</TT> que começam com `S' (de start). Estes scripts
são apenas vínculos para os roteiros em outro diretório, normalmente
chamado <TT>init.d</TT>.

<P>
<!--
So our run-level script was called by <TT>init</TT>, and it is looking
in a directory for scripts starting with `S'. It might find
<TT>S10syslog</TT> first. The numbers tell the run-level script which
order to run them in. So in this case <TT>S10syslog</TT> gets run
first, since there were no scripts starting with S00 ... S09. But
<TT>S10syslog</TT> is really a link to <TT>/etc/init.d/syslog</TT>
which is a script to start and stop the system logger. Because the
link starts with an `S', the run-level script knows to execute the
<TT>syslog</TT> script with a ``start'' parameter. There are
corresponding links starting with `K' (for kill), which specify what
to shut down and in what order when leaving the run-level.
-->
Portanto nosso roteiro de nível de execução é chamado <TT>init</TT>, e
está procurando num diretório por roteiros começando com `S'. Talvez
encontre primeiro <TT>S10syslog</TT>. Os números dizem ao roteiro de
nível de execução qual a ordem em que devem ser executados. Neste caso
<TT>S10syslog</TT> é o primeiro, porque não existem roteiros começando
com S00 .. S09. Porém <TT>S10syslog</TT> é na verdade um vínculo para
<TT>/etc/init.d/syslog</TT>, que é o roteiro para iniciar e parar o
agente de log do sistema. O roteiro de nível de execução sabe que deve
executar o roteiro <TT>syslog</TT> com o parâmetro ``start'' porque o
vínculo começa com `S'. Existem os vínculos correspondentes começando
com `K' (de kill), que especificam o que terminar e em que ordem
quando estivermos saindo do nível de execução.

<P>
<!--
To change what subsystems start up by default, you must set up these
links in the <TT>rcN.d</TT> directory, where N is the default runlevel
set in your <TT>inittab</TT>.
-->
Para modificar quais subsistemas iniciar por padrão, defina os
vínculos no diretório <TT>rcN.d</TT>, onde N é o nível de execução
padrão em seu <TT>inittab</TT>.

<P>
<!--
The last important thing that init does is to start some
<TT>getty</TT>'s. These are ``respawned'' which means that if they
stop, <TT>init</TT> just starts them again. Most distributions come
with six virtual terminals. You may want less than this to save
memory, or more so you can leave lots of things running and quickly
flick to them as you need them. You may also want to run a
<TT>getty</TT> for a text terminal or a dial in modem. In this case
you will need to edit the <TT>inittab</TT> file.
-->
A última coisa importante que o init faz é iniciar alguns
<TT>getty</TT>. Se algum deles parar, é ``recriado'' pelo
<TT>init</TT>. A maioria das distribuições vem com seis terminais
virtuais. Você pode querer menos para economizar memória, ou mais para
ter muitas coisas rodando ao mesmo tempo e visualizá-las quando for
necessário rapidamente. Você pode querer também executar um
<TT>getty</TT> para um terminal modo texto ou uma discagem em
modem. Nesse caso você devera editar o arquivo <TT>inittab</TT>.

<SECT1>Configuração
<P>
<!--
<TT>/etc/inittab</TT> is the top level configuration file for init.
-->
<TT>/etc/inittab</TT> é o arquivo de configuração de mais alto nível
para o init.

<P>
<!--
The <TT>rcN.d</TT> directories, where N = 0, 1, ..., 6 determine what
subsystems are started.
-->
Os diretórios <TT>rcN.d</TT>, onde N = 0, 1, ..., 6 determinam quais
subsistemas serão inicializados.

<P>
<!--
Somewhere in one of the scripts invoked by init, the <TT>mount -a</TT>
command will be issued. This means mount all the file systems that are
supposed to be mounted. The file <TT>/etc/fstab</TT> defines what is
supposed to be mounted. If you want to change what gets mounted where
when your system starts up, this is the file you will need to
edit. There is a man page for <TT>fstab</TT>.
-->
Em algum lugar num dos roteiros invocados pelo init, aparecerá o comando
<TT>mount -a</TT>. Isto significa montar todos os sistemas arquivos
que devem ser montados. O arquivo <TT>/etc/fstab</TT> define o que
deve ser montado. Se quiser mudar o que será montado quando seu
sistema inicializar, é este arquivo que você deve editar. Há uma
página de manual para o <TT>fstab</TT>.

<SECT1>Exercícios
<P>
<!--
Find the <TT>rcN.d</TT> directory for the default run-level of your
system and do a <TT>ls -l</TT> to see what the files are links to.
-->
Encontre o diretório <TT>rcN.d</TT> para o nível de execução padrão de
seu sistema e digite <TT>ls -l</TT> para ver para quais arquivos os
vínculos apontam.

<P>
<!--
Change the number of gettys that run on your system.
-->
Modifique o número de gettys que o seu sistema roda.

<P>
<!--
Remove any subsystems that you don't need from your default
run-level.
-->
Remova qualquer subsistema desnecessário do seu nível de execução
padrão.

<P>
<!--
See how little you can get away with starting.
-->
Veja o quanto você pode reduzir a inicialização.

<P>
<!--
Set up a floppy disk with lilo, a kernel and a statically linked
"hello world" program called <TT>/sbin/init</TT> and watch it boot up
and say hello.
-->
Prepare um disquete com o lilo, um kernel e um programa ``olá mundo''
vinculado estaticamente chamado <TT>/sbin/init</TT> e veja ele
inicializar e dizer olá.

<P>
<!--
Watch carefully as your system starts up, and take notes about what it
tells you is happening. Or print a section of your system log
<TT>/var/log/messages</TT> from start up time. Then starting at
<TT>inittab</TT>, walk through all the scripts and see what code does
what. You can also put extra start up messages in, such as
-->
Observe atenciosamente a inicialização de seu sistema e tome notas
sobre o que ele diz estar acontecendo. Ou imprima uma seção do
log do seu sistema <TT>/var/log/messages</TT> desde o momento da
inicialização. Então começando pelo <TT>inittab</TT>, siga todos os
roteiros e veja o que faz cada código. Você também pode colocar
mensagens de inicialização extras nele, como por exemplo:

<!--
<VERB>
	echo "Hello, I am rc.sysinit"
</VERB>
-->
<VERB>
	echo "Olá, sou o rc.sysinit"
</VERB>

<!--
This is a good exercise in learning Bash shell scripting too, some of
the scripts are quite complicated. Have a good Bash reference handy.
-->
Este também é um bom exercício para aprender escrever roteiros de Bash,
alguns dos roteiros são bastante complicados. Tenha um bom guia de
referência do Bash a mão.


<SECT1>Mais Informações
<P>
<ITEMIZE>
<ITEM>
<!--
There are man pages for the <TT>inittab</TT> and <TT>fstab</TT>
files. Type (eg) <TT>man inittab</TT> into a shell to see it.
-->
Existem páginas de manual para os arquivos <TT>inittab</TT> e
<TT>fstab</TT>. Digite (por exemplo) <TT>man inittab</TT> num shell
para vê-las.

<ITEM>
<!--
The Linux System Administrators Guide has a good <URL
URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" NAME="section"> on
init.
-->
The Linux System Administrators Guide tem uma boa <URL
URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" NAME="seção"> sobre o
init.

<ITEM>
<!--
source code, see <URL
URL="http://www.netspace.net.au/~gok/power2bash" NAME="Building a
Minimal Linux System from Source Code"> for urls
-->
código fonte, veja
<URL
URL="http://www.netspace.net.au/~gok/power2bash" NAME="Building a
Minimal Linux System from Source Code"> para encontrar urls

</ITEMIZE>



<SECT>O sistema de arquivos
<P>
<!--
In this section, I will be using the word ``filesystem'' in two
different ways. There are filesystems on disk partitions and other
devices, and there is the filesystem as it is presented to you by a
running Linux system. In Linux, you ``mount'' a disk filesystem onto
the system's filesystem.
-->
Nesta seção, estarei usando a expressão ``sistema de arquivos'' de
duas formas diferentes. Existem sistemas de arquivos em partições do
disco ou outros dispositivos, e existe o sistema de arquivos como lhe
é apresentado pelo sistema Linux em funcionamento. No Linux, você
``monta'' um sistema de arquivos em disco no sistema de arquivos do
sistema.

<P>
<!--
In the previous section I mentioned that init scripts check and mount
the filesystems. The commands that do this are <TT>fsck</TT> and
<TT>mount</TT> respectively.
-->
Na seção anterior mencionei que os roteiros do init verificam e montam
sistemas de arquivos. Os comandos que fazem isso são <TT>fsck</TT> e
<TT>mount</TT> respectivamente.

<P>
<!--
A hard disk is just a big space that you can write ones and zeros
on. A filesystem imposes some structure on this, and makes it look
like files within directories within directories... Each file is
represented by an inode, which says who's file it is, when it was
created and where to find its contents. Directories are also
represented by inodes, but these say where to find the inodes of the
files that are in the directory. If the system wants to read
<TT>/home/greg/bigboobs.jpeg</TT>, it first finds the inode for the
root directory <TT>/</TT> in the ``superblock'', then finds the inode
for the directory <TT>home</TT> in the contents of <TT>/</TT>, then
finds the inode for the directory <TT>greg</TT> in the contents of
<TT>/home</TT>, then the inode for <TT>bigboobs.jpeg</TT> which will
tell it which disk blocks to read.
-->
Um disco rígido é apenas um grande espaço onde você pode escrever
zeros e uns. Um sistema de arquivos impõe certa estrutura nisto,
fazendo parecer que existem arquivos em seus diretórios e estes em
seus diretórios... Cada arquivo é representado por um inode, que diz a
quem pertence o arquivo, quando foi criado e onde encontrar seu
conteúdo. Diretórios também são representados por inodes, mas estes
dizem onde encontrar os inodes dos arquivos que estão no diretório. Se
o sistema quer ler <TT>/home/greg/bigboobs.jpeg</TT>, primeiro ele
encontra o inode para o diretório raíz <TT>/</TT> no ``superbloco'',
em seguida encontra o inode para o diretório <TT>home</TT> no conteúdo
de <TT>/</TT>, depois encontra o inode para o diretório <TT>greg</TT>
no conteúdo de <TT>/home</TT>, finalmente o inode para
<TT>bigboobs.jpeg</TT> que irá dizer quais blocos do disco ler.

<P>
<!--
If we add some data to the end of a file, it could happen that the
data is written before the inode is updated to say that the new blocks
belong to the file, or vice versa. If the power cuts out at this
point, the filesystem will be broken. It is this kind of thing that
<TT>fsck</TT> attempts to detect and repair.
-->
Se acrescentarmos algum dado ao fim do arquivo, pode acontecer dos
dados serem escritos antes do inode ser atualizado para dizer quais os
novos blocos pertencem ao arquivo, ou vice versa. Se houver um corte
de energia neste ponto, o sistema de arquivos estará corrompido. É
este tipo de coisa que o <TT>fsck</TT> tenta detectar e reparar.

<P>
<!--
The mount command takes a filesystem on a device, and adds it to the
heirarchy that you see when you use your system. Usually, the kernel
mounts its root file system read-only. The mount command is used to
remount it read-write after <TT>fsck</TT> has checked that it is ok.
-->
O comando mount pega um sistema de arquivos num dispositivo, e
o acrescenta à hierarquia que você vê quando usa seu
sistema. Normalmente, o kernel monta o sistema de arquivos raíz
somente para leitura. O comando mount é usado para remontá-lo para
leitura e escrita depois que o <TT>fsck</TT> verificou que está tudo
bem.

<P>
<!--
Linux supports other kinds of filesystem too: msdos, vfat, minix and
so on. The details of the specific kind of filesystem are abstracted
away by the virtual file system (VFS). I won't go into any detail on
this though. There is a discussion of it in ``The Linux Kernel'' (see
section <REF ID="Kernel" NAME="The Linux Kernel"> for a url)
-->
O Linux também suporta outros tipos de sistema de arquivos: msdos,
vfat, minix e outros mais. Os detalhes de um tipo específico de
sistema de arquivos são abstraídos pelo sistema de arquivos virtual
(VFS). Não vou entrar em detalhes sobre isto. Existe uma discussão
sobre isso no ``The Linux Kernel'' (há uma URL na seção <REF
ID="Kernel" NAME="O Kernel do Linux">).

<P>
<!--
A completely different kind of filesystem gets mounted on
<TT>/proc</TT>. It is really a representation of things in the
kernel. There is a directory there for each process running on the
system, with the process number as the directory name. There are also
files such as <TT>interrupts</TT>, and <TT>meminfo</TT> which tell you
about how the hardware is being used. You can learn a lot by exploring
<TT>/proc</TT>.
-->
Um tipo de sistema de arquivos completamente diferente é montado em
<TT>/proc</TT>. É na verdade uma representação das coisas no
kernel. Há um diretório ali para cada processo rodando no sistema,
onde o número do processo é o nome do diretório. Também existem
arquivos como <TT>interrupts</TT> e <TT>meminfo</TT> que dizem sobre
como o hardware está sendo usado. Você pode aprender bastante ao
explorar <TT>/proc</TT>.

<SECT1>Configuração
<P>
<!--
There are parameters to the command <TT>mke2fs</TT> which creates ext2
filesystems. These control the size of blocks, the number of inodes
and so on. Check the <TT>mke2fs</TT> man page for details.
-->
Existem parâmetros para o comando <TT>mke2fs</TT> que cria sistemas de
arquivos ext2. Estes controlam o tamanho dos blocos, o número de
inodes, e assim por diante. Veja a página de manual do <TT>mke2fs</TT>
para mais detalhes.

<P>
<!--
What gets mounted where on your filesystem is controlled by the
<TT>/etc/fstab</TT> file. It also has a man page. 
-->
O que é montado em seu sistema de arquivos é controlado pelo arquivo
<TT>/etc/fstab</TT>. Também há uma página de manual para ele.

<SECT1>Exercícios
<P>
<!--
Make a very small filesystem, and view it with a hex viewer. Identify
inodes, superblocks and file contents.
-->
Faça um sistema de arquivos bem pequeno, e visualize-o com um
visualizador hexadecimal. Identifique o superbloco, os inodes e o
conteúdo dos arquivos.

<P>
<!--
I believe there are tools that give you a graphical view of a
filesystem. Find one, try it out, and email me the url and a review!
-->
Acredito que existam ferramentas que te dão uma visão gráfica do
sistema de arquivos. Encontre uma, teste, e me mande um e-mail com a
url e comentários.

<P>
<!--
Check out the ext2 filesystem code in the Kernel.
-->
Veja o código do kernel para o sistema de arquivos ext2.

<SECT1>Mais Informações
<P>
<ITEMIZE>
<ITEM>
<!--
Chapter 9 of the LDP book ``The Linux Kernel'' is an excellent
description of filesystems. You can find it at the Australian LDP <URL
URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" NAME="mirror">
-->
O capítulo 9 do livro LDP ``The Linux Kernel'' tem uma excelente
descrição dos sistemas de arquivos. Você pode encontrá-lo no <URL
URL="http://mirror.aarnet.edu.au/linux/LDP/LDP/" NAME="espelho">
Australiano do LDP.

<ITEM>
<!--
The <TT>mount</TT> command is part of the util-linux package, there is
a link to it in <URL URL="http://www.netspace.net.au/~gok/power2bash"
NAME="Building a Minimal Linux System from Source Code">
-->
O comando <TT>mount</TT> é parte do pacote util-linux; há uma URL em
<URL URL="http://www.netspace.net.au/~gok/power2bash" NAME="Building a
Minimal Linux System from Source Code">

<ITEM>
<!--
man pages for <TT>mount</TT>, <TT>fstab</TT>, <TT>fsck</TT>,
<TT>mke2fs</TT> and <TT>proc</TT>
-->
Páginas de manual para o <TT>mount</TT>, <TT>fstab</TT>,
<TT>fsck</TT>, <TT>mke2fs</TT> e <TT>proc</TT>.

<ITEM>
<!--
The file <TT>Documentation/proc.txt</TT> in the Linux source code
explains the <TT>/proc</TT> filesystem.
-->
O arquivo <TT>Documentation/proc.txt</TT> no código fonte do Linux
explica o sistema de arquivos <TT>/proc</TT>.

<ITEM>
<!--
EXT2 File System Utilities <URL
URL="http://web.mit.edu/tytso/www/linux/e2fsprogs.html"
NAME="ext2fsprogs"> home page <URL
URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/filesystems/ext2/"
NAME="ext2fsprogs"> Australian mirror. There is also a Ext2fs-overview
document here, although it is out of date, and not as readable as
chapter 9 of ``The Linux Kernel''
-->
A página do EXT2 File System Utilities <URL
URL="http://web.mit.edu/tytso/www/linux/e2fsprogs.html"
NAME="ext2fsprogs"> e o <URL
URL="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/filesystems/ext2/"
NAME="espelho"> Australiano. Há ali um documento Ext2fs-overview,
porém está obsoleto e não é tão legível quanto o capítulo nove do
``The Linux Kernel''.

<ITEM>
<!--
<LABEL ID="FHS">
<URL URL="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/"
NAME="Unix File System Standard"> Another <URL
URL="http://www.pathname.com/fhs/" NAME="link"> to the Unix File
System Standard. This describes what should go where in a Unix file
system, and why. It also has minimum requirements for the contents of
<TT>/bin</TT>, <TT>/sbin</TT> and so on. This is a good reference if
your goal is to make a minimal yet complete system.
-->
<LABEL ID="FHS">
<URL URL="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/"
NAME="Unix File System Standard"> (outro <URL
URL="http://www.pathname.com/fhs/" NAME="link">). Este descreve o que
deve ter em um sistema de arquivos Unix e por que. Também os
requisitos mínimos para <TT>/bin</TT>, <TT>/sbin</TT> e outros. Esta é
uma boa referência se seu objetivo é criar um sistema mínimo porém
completo.

</ITEMIZE>



<SECT>Daemons do Kernel
<P>
<!--
If you issue the <TT>ps aux</TT> command, you will see something like
the following:
-->
Ao executar o comando <TT>ps aux</TT>, verá algo semelhante a isto:

<P>
<VERB>
USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
root         1  0.1  8.0  1284   536   ? S    07:37   0:04 init [2] 
root         2  0.0  0.0     0     0   ? SW   07:37   0:00 (kflushd)
root         3  0.0  0.0     0     0   ? SW   07:37   0:00 (kupdate)
root         4  0.0  0.0     0     0   ? SW   07:37   0:00 (kpiod)
root         5  0.0  0.0     0     0   ? SW   07:37   0:00 (kswapd)
root        52  0.0 10.7  1552   716   ? S    07:38   0:01 syslogd -m 0 
root        54  0.0  7.1  1276   480   ? S    07:38   0:00 klogd 
root        56  0.3 17.3  2232  1156   1 S    07:38   0:13 -bash 
root        57  0.0  7.1  1272   480   2 S    07:38   0:01 /sbin/agetty 38400 tt
root        64  0.1  7.2  1272   484  S1 S    08:16   0:01 /sbin/agetty -L ttyS1
root        70  0.0 10.6  1472   708   1 R   Sep 11   0:01 ps aux 
</VERB>

<P>
<!--
This is a list of the processes running on the system. The information
comes from the <TT>/proc</TT> filesystem that I mentioned in the
previous section. Note that <TT>init</TT> is process number
one. Processes 2, 3, 4 and 5 are kflushd, kupdate, kpiod and
kswapd. There is something strange here though: notice that in both
the virtual storage size (SIZE) and the Real Storage Size (RSS)
columns, these processes have zeroes. How can a process use no memory?
-->
Esta é a lista de processos rodando no sistema. A informação é dada
pelo sistema de arquivos <TT>/proc</TT>, que mencionei na seção
anterior. Note que o <TT>init</TT> é o processo número um. Os
processos dois, três, quatro e cinco são kflushd, kupdate, kpiod e
kswapd. Contudo há algo estranho aqui: note que tanto na coluna do
tamanho do armazenamento virtual (SIZE) quanto o tamanho do
armazenamento real (Real Storage Size, RSS) estes processos tem
zeros. Como pode um processo não usar memória?

<P>
<!--
These processes are the kernel daemons. Most of the kernel does not
show up on process lists at all, and you can only work out what memory
it is using by subtracting the memory available from the amount on
your system. The kernel daemons are started after init, so they get
process numbers like normal processes do. But their code and data
lives in the kernel's part of the memory.
-->
Estes processos são daemons do kernel. A maior parte do kernel não é
mostrada na lista de processos, e você apenas poderá calcular quanta
memória ele está usando subtraindo a memória disponível da que há em
seu sistema. Os daemons do kernel são iniciados após o init, portanto
recebem PID's (números de processo) assim como processos
normais. Porém, seu código e dados residem na parte de memória do
kernel.

<P>
<!--
There are brackets around the entries in the command column because
the <TT>/proc</TT> filesystem does not contain command line
information for these processes.
-->
A coluna de comando está entre parênteses porque o sistema de arquivos
<TT>/proc</TT> não tem a informação da linha de comandos para estes
processos.

<P>
<!--
So what are these kernel daemons for? Previous versions of this
document had a plea for help, as I didn't know much about the kernel
daemons. The following partial story has been patched together from
various replies to that plea, for which I am most grateful. Further
clues, references and corrections are most welcome!
-->
Então para que servem estes daemons do kernel? Versões anteriores
deste documento tinha um pedido de ajuda, já que eu não sei muito
sobre os daemons do kernel. A história parcial que segue foi feita com
pedaços das várias respostas deste pedido, pelas quais eu sou muito
grato. Mais dicas, referências e correções são bem-vindas!

<P>
<!--
Input and output is done via <em>buffers</em> in memory. This allows
things to run faster. What programs write can be kept in memory, in a
buffer, then written to disk in larger more efficient chunks. The
daemons <TT>kflushd</TT> and <TT>kupdate</TT> handle this work:
<TT>kupdate</TT> runs periodically (5 seconds?) to check whether there
are any dirty buffers. If there are, it gets <TT>kflushd</TT> to flush
them to disk.
-->
A entrada e a saída é feita através de <EM>buffers</EM> na
memória. Isto permite as coisas rodarem mais rápido. O que os
programas escrevem pode ser mantido na memória, num buffer, depois
escrito para o disco em pedaços maiores e mais eficientes. Os daemons
<TT>kflushd</TT> e <TT>kupdate</TT> controlam esta tarefa:
<TT>kupdate</TT> roda periodicamente (5 segundos?) para verificar
se existe algum buffer cheio. Se existir, faz com que <TT>kflushd</TT>
o escreva para o disco.

<P>
<!--
Processes often have nothing to do, and ones that are running often
don't need all of their code and data in memory. This means we can
make better use of our memory, by shifting unused parts of running
programs out to the swap partition(s) of the hard disk. Moving this
data in and out of memory as needed is done by <TT>kpiod</TT> and
<TT>kswapd</TT>. Every second or so, <TT>kswapd</TT> wakes up to check
out the memory situation, and if something out on the disk is needed
in memory, or there is not enough free memory, <TT>kpiod</TT> is
called in.
-->
Muitas vezes os processos não tem nada para fazer, e os que estão
rodando às vezes não precisam ter todo o seu código na memória. Isto
significa que podemos fazer melhor uso da memória retirando as partes
não usadas dos programas em execução para a(s) partição(s) de troca
(swap) do disco rígido. Mover estes dados para dentro e para fora da
memória quando necessário é feito pelo <TT>kpiod</TT> e
<TT>kswapd</TT>. Mais ou menos a cada segundo, <TT>kswapd</TT> acorda
para verificar a situação da memória, e se alguma coisa no disco é
necessária na memória ou não há memória livre suficiente,
<TT>kpiod</TT> é chamado.

<P>
<!--
There might also be a <TT>kapmd</TT> daemon running on your system if
you have configured automatic power management into your kernel.
-->
Também pode haver o daemon <TT>kapmd</TT> rodando em seu sistema se
você configurou o gerenciamento automático de energia em seu kernel.

<SECT1>Configuração
<P>
<!--
The program <TT>update</TT> allows you to configure <TT>kflushd</TT>
and <TT>kswapd</TT>. Try <TT>update -h</TT> for some information.
-->
O programa <TT>update</TT> te permite configurar o <TT>kflushd</TT> e
<TT>kswapd</TT>. Experimente <TT>update -h</TT> para mais informações.

<P>
<!--
Swap space is turned on by <TT>swapon</TT> and off by
<TT>swapoff</TT>. The init script (<TT>/etc/rc.sysinit</TT> or
<TT>/etc/rc.d/rc.sysinit</TT>) usually calls <TT>swapon</TT> as the
system is coming up. I'm told that <TT>swapoff</TT> is handy for
saving power on laptops.
-->
O espaço de troca é ativado por <TT>swapon</TT> e desativado por
<TT>swapoff</TT>. O roteiro do init (<TT>/etc/rc.sysinit</TT> ou
<TT>/etc/rc.d/rc.sysinit</TT>) normalmente chama <TT>swapon</TT>
quando o sistema inicializa. Me disseram que <TT>swapoff</TT> é útil
para economizar energia nos portáteis.

<SECT1>Exercícios
<P>
<!--
Do an <TT>update -d</TT>, note the blatherings on the last line about
``threshold for buffer fratricide''. Now there's an intriguing
concept, go investigate!
-->
Execute <TT>update -d</TT>, note a frase <!-- ?? --> na última linha
sobre ``threshold for buffer fratricide'' (limite para o fratricídio do
buffer). Aqui está um conceito intrigante, investigue!

<P>
<!--
Change directory to <TT>/proc/sys/vm</TT> and <TT>cat</TT> the files
there. See what you can work out.
-->
Vá ao diretório <TT>/proc/sys/vm</TT> e visualize os arquivos ali com
o <TT>cat</TT>. Veja se consegue entender.

<SECT1>Mais Informações
<P>
<!--
The Linux Documentation Project's ``The Linux Kernel'' (see section
<REF ID="Kernel" NAME="The Linux Kernel"> for a url)
-->
``The Linux Kernel'' de The Linux Documentation Project (veja a seção
<REF ID="Kernel" NAME="O Kernel do Linux"> para encontrar uma url)

<P>
<!--
The Linux kernel source code, if you are brave enough! The
<TT>kswapd</TT> code is in <TT>linux/mm/vmscan.c</TT>, and
<TT>kflushd</TT> and <TT>kupdate</TT> are in
<TT>linux/fs/buffer.c</TT>.
-->
O código fonte do kernel do Linux, se você for corajoso suficiente. O
código do <TT>kswapd</TT> está em <TT>linux/mm/vmscan.c</TT>, e
<TT>kflushd</TT> e <TT>kupdate</TT> estão em
<TT>linux/fs/buffer.c</TT>.



<SECT>O agente de log do sistema
<P>
<!--
Init starts the <TT>syslogd</TT> and <TT>klogd</TT> daemons. They
write messages to logs. The kernel's messages are handled by
<TT>klogd</TT>, while <TT>syslogd</TT> handles log messages from other
processes. The main log is <TT>/var/log/messages</TT>. This is a good
place to look if something is going wrong with your system. Often
there will be a valuable clue in there.
-->
O init inicializa os daemons <TT>syslogd</TT> e o <TT>klogd</TT>. Eles
escrevem as mensagens para logs. As mensagens do kernel são
manipuladas pelo <TT>klogd</TT>, enquanto o <TT>syslogd</TT> manipula
as mensagens de outros processos. O registro de log principal é
<TT>/var/log/messages</TT>. Quando alguma coisa está errada, este é um
bom lugar para procurar o que é. Muitas vezes existem dicas valiosas
ali.

<SECT1>Configuração
<P>
<!--
The file <TT>/etc/syslog.conf</TT> tells the loggers what messages to
put where. Messages are identified by which service they come from,
and what priority level they are. This configuration file consists of
lines that say messages from service x with priority y go to z, where
z is a file, tty, printer, remote host or whatever.
-->
O arquivo <TT>/etc/syslog.conf</TT> diz aos agentes de log quais
mensagens registrar e onde. As mensagens são identificadas pelos
serviços de onde se originam e qual nível de prioridade elas têm. Este
arquivo de configuração consiste de linhas que dizem que as mensagens
do serviço x com prioridade y vão para z, onde z é um arquivo, tty,
impressora, uma máquina remota, ou qualquer outra coisa.

<P>
<!--
NOTE: Syslog requires the <TT>/etc/services</TT> file to be
present. The services file allocates ports. I am not sure whether
syslog needs a port allocated so that it can do remote logging, or
whether even local logging is done through a port, or whether it just
uses <TT>/etc/services</TT> to convert the service names you type
<TT>/etc/syslog.conf</TT> into port numbers.
-->
NOTA: O syslog exige que o arquivo <TT>/etc/services</TT> esteja
presente. O arquivo services aloca portas. Não estou certo se o syslog
precisa de uma porta para poder fazer o registro remotamente, ou se
mesmo o registro local é feito através uma porta, ou se ele usa o
arquivo <TT>/etc/services</TT> apenas para converter os nomes dos
serviços que você digita no arquivo <TT>/etc/syslog.conf</TT> em
números de portas.

<SECT1>Exercícios
<P>
<!--
Have a look at your system log. Find a message you don't understand,
and find out what it means.
-->
Dê uma olhada no log do seu sistema. Encontre uma mensagem que você
não compreende e descubra o que significa.

<P>
<!--
Send all your log messages to a tty. (set it back to normal once done)
-->
Mande todas as mensagens do seu log para um tty. (depois coloque tudo
de volta ao normal)

<SECT1>Mais Informações
<P>
<!--
Australian sysklogd <URL
URL="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/"
NAME="Mirror">
-->
<URL
URL="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/"
NAME="Espelho"> Australiano do sysklogd



<SECT>Getty e Login
<P>
<!--
Getty is the program that enables you to log in through a serial
device such as a virtual terminal, a text terminal, or a modem. It
displays the login prompt. Once you enter your username, getty hands
this over to <TT>login</TT> which asks for a password, checks it out
and gives you a shell.
-->
Getty é o programa que te permite efetuar login através de um
dispositivo serial como um terminal virtual, um terminal texto, ou um
modem. Ele mostra a linha de comandos do login. Uma vez que você
introduz seu nome de usuário, o getty o entrega para o <TT>login</TT>,
que te pede a senha, a verifica e te fornece um shell.

<P>
<!--
There are many getty's available. Some distributions, including Red
Hat use a very small one called <TT>mingetty</TT> that only works with
virtual terminals.
-->
Existem muitos gettys disponíveis. Algumas distribuições, incluindo a
Red Hat, usam um muito pequeno chamado <TT>mingetty</TT> que funciona
apenas com terminais virtuais.

<P>
<!--
The <TT>login</TT> program is part of the util-linux package, which
also contains a getty called <TT>agetty</TT>, which works fine. This
package also contains <TT>mkswap</TT>, <TT>fdisk</TT>,
<TT>passwd</TT>, <TT>kill</TT>, <TT>setterm</TT>, <TT>mount</TT>,
<TT>swapon</TT>, <TT>rdev</TT>, <TT>renice</TT>, <TT>more</TT> (the
program) and more (ie more programs).
-->
O programa <TT>login</TT> é parte do pacote util-linux, que também
contém um getty chamado <TT>agetty</TT>, que funciona muito bem. Este
pacote também contém <TT>mkswap</TT>, <TT>fdisk</TT>, <TT>passwd</TT>,
<TT>kill</TT>, <TT>setterm</TT>, <TT>mount</TT>, <TT>swapon</TT>,
<TT>rdev</TT>, <TT>renice</TT>, <TT>more</TT> (o programa) e mais
(quer dizer, mais programas). <!-- Na tradução para o espanhol há uma
nota do tradutor aqui sobre o trocadilho -->

<SECT1>Configuração
<P>
<!--
The message that comes on the top of your screen with your login
prompt comes from <TT>/etc/issue</TT>. Gettys are usually started in
<TT>/etc/inittab</TT>. Login checks user details in
<TT>/etc/passwd</TT>, and if you have password shadowing,
<TT>/etc/shadow</TT>.
-->
A mensagem que aparece no topo da sua tela com a linha de comandos do
login vem de <TT>/etc/issue</TT>. Os gettys geralmente são iniciados
por <TT>/etc/inittab</TT>. O login verifica os detalhes sobre o
usuário em <TT>/etc/passwd</TT> e, se o sistema tem mascaramento de
senhas, <TT>/etc/shadow</TT>.

<SECT1>Exercícios
<P>
<!--
Create a <TT>/etc/passwd</TT> by hand. Passwords can be set to null,
and changed with the program <TT>passwd</TT> once you log on. See the
man page for this file Use <TT>man 5 passwd</TT> to get the man page
for the file rather than the man page for the program.
-->
Crie um <TT>/etc/passwd</TT> manualmente. As senhas podem ser nulas, e
mudadas com o programa <TT>passwd</TT> uma vez que você efetuar
login. Veja a página de manual para este arquivo, use <TT>man 5
passwd</TT> para obter a página de manual para o arquivo ao invés da
página de manual para o programa.



<SECT>Bash
<P>
<!--
If you give <TT>login</TT> a valid username and password combination,
it will check in <TT>/etc/passwd</TT> to see which shell to give
you. In most cases on a Linux system this will be <TT>bash</TT>. It is
<TT>bash</TT>'s job to read your commands and see that they are acted
on. It is simultaneously a user interface, and a programming language
interpreter.
-->
Se você der ao <TT>login</TT> uma combinação válida do nome de usuário
e senha, ele irá verificar em <TT>/etc/passwd</TT> qual shell te
fornecer. Na maioria dos casos num sistema Linux será o <TT>bash</TT>. É
tarefa do <TT>bash</TT> ler seus comandos e fazer com que sejam
executados. Ele é simultaneamente uma interface de usuário e um
interpretador de uma linguagem de programação.

<P>
<!--
As a user interface it reads your commands, and executes them itself
if they are ``internal'' commands like <TT>cd</TT>, or finds and
executes a program if they are ``external'' commands like <TT>cp</TT>
or <TT>startx</TT>. It also does groovy stuff like keeping a command
history, and completing filenames.
-->
Como interface de usuário ele lê seus comandos e os executa se forem
comandos ``internos'' como  <TT>cd</TT>, ou procura e executa um
programa se ele for ``externo'' como <TT>cp</TT> ou
<TT>startx</TT>. Ele também faz coisas excelentes como manter um
histórico dos comandos e o completamento dos nomes de arquivos.

<P>
<!--
We have already seen <TT>bash</TT> in action as a programming language
interpreter. The scripts that <TT>init</TT> runs to start the system
up are usually shell scripts, and are executed by
<TT>bash</TT>. Having a proper programming language, along with the
usual system utilities available at the command line makes a very
powerful combination, if you know what you are doing. For example
(smug mode on) I needed to apply a whole stack of ``patches'' to a
directory of source code the other day. I was able to do this with the
following single command:
-->
Nós já vimos o <TT>bash</TT> em ação como interpretador de linguagem
de programação. Os roteiros que o <TT>init</TT> roda para inicializar o
sistema normalmente são roteiros shell, e são executados pelo
<TT>bash</TT>. Ter uma verdadeira linguagem de programação junto
com os utilitários habituais do sistema disponíveis na linha de
comandos é uma combinação muito poderosa, se souber o que estiver
fazendo. Por exemplo (modo convencido ativado) outro dia precisei
aplicar um monte de ``remendos'' a um diretório de código fonte. Fui
capaz de fazê-lo usando apenas este comando:

<VERB>
for f in /home/greg/sh-utils-1.16*.patch; do patch -p0 < $f; done;
</VERB>

<P>
<!--
This looks at all the files in my home directory whose names start
with <TT>sh-utils-1.16</TT> and end with <TT>.patch</TT>. It then
takes each of these in turn, and sets the variable <TT>f</TT> to it
and executes the commands between <TT>do</TT> and <TT>done</TT>. In
this case there were 11 patch files, but there could just as easily
have been 3000.
-->
Este comando procura em todos os arquivos em meu diretório pessoal cujos nomes
começam com <TT>sh-utils-1.16</TT> e terminam com
<TT>.patch</TT>. Para cada arquivo encontrado ele aponta a variável
<TT>f</TT> para aquele arquivo e executa os comandos entre <TT>do</TT>
e <TT>done</TT>. Neste caso havia 11 arquivos para ``remendar'', mas
seria igualmente fácil se houvesse três mil.

<SECT1>Configuração
<P>
<!--
The file <TT>/etc/profile</TT> controls the system-wide behaviour of
bash. What you put in here will affect everybody who uses bash on your
system. It will do things like add directories to the <TT>PATH</TT>,
set your <TT>MAIL</TT> directory variable.
-->
O arquivo <TT>/etc/profile</TT> controla o comportamento do bash para
todo o sistema. O que você colocar aqui irá afetar todo mundo que usa
o bash em seu sistema. Ele fará coisas como adicionar diretórios ao
<TT>PATH</TT>, definir sua variável de diretório <TT>MAIL</TT>, etc.

<P>
<!--
The default behaviour of the keyboard often leaves a lot to be
desired. It is actually readline that handles this. Readline is a
separate package that handles command line interfaces, providing the
command history and filename completion, as well as some advanced line
editing features. It is compiled into bash. By default, readline is
configured using the file <TT>.inputrc</TT> in your home
directory. The bash variable INPUTRC can be used to override this for
bash. For example in Red Hat 6, <TT>INPUTRC</TT> is set to
<TT>/etc/inputrc</TT> in <TT>/etc/profile</TT>. This means that
backspace, delete, home and end keys work nicely for everyone.
-->
O comportamento padrão do teclado muitas vezes deixa muito a
desejar. Na verdade é o readline que manipula isto. O readline é um
pacote separado que manipula interfaces de linha de comandos,
oferecendo o histórico dos comando e o completamento de nomes de
arquivos, assim como algumas características avançadas de edição de
linhas. Está compilado no bash. Por padrão, o readline é configurado
usando o arquivo <TT>.inputrc</TT> em seu diretório pessoal. A
variável do bash INPUTRC pode ser usada para substituir isto para o
bash. Por exemplo: no Red Hat 6, <TT>INPUTRC</TT> é definida em
<TT>/etc/profile</TT> para <TT>/etc/inputrc</TT>. Isto significa que
as teclas de retrocesso (backspace), apagar (delete), início (home) e
fim (end) funcionam bem para todo mundo.

<P>
<!--
Once bash has read the system-wide configuration file, it looks for
your personal configuration file. It checks in your home directory for
<TT>.bash_profile</TT>, <TT>.bash_login</TT> and <TT>.profile</TT>. It
runs the first one of these it finds. If you want to change the way
bash behaves for you, without changing the way it works for others, do
it here. For example, many applications use environment variables to
control how they work. I have the variable <TT>EDITOR</TT> set to
<TT>vi</TT> so that I can use vi in Midnight Commander (an excellent
console based file manager) instead of its editor. 
-->
Uma vez que o bash leu o arquivo de configuração para todo o sistema,
ele procura pelo seu arquivo de configuração pessoal. Ele procura em
seu diretório pessoal por <TT>.bash_profile</TT>, <TT>.bash_login</TT>
e <TT>.profile</TT>. Ele roda o primeiro que encontrar. Se quiser
mudar a forma que o bash se comporta para você, sem modificar o modo
que se comporta para os outros, faça isto aqui. Por exemplo, muitos
aplicativos usam variáveis de ambiente para controlar seu
funcionamento. Eu tenho a variável <TT>EDITOR</TT> definida para
<TT>vi</TT> de forma que posso usar o vi no Midnight Commander (um
excelente gerenciador de arquivos no modo console) em vez do seu
próprio editor.

<SECT1>Exercícios
<P>
<!--
The basics of bash are easy to learn. But don't stop there: there is
an incredible depth to it. Get into the habit of looking for better
ways to do things.
-->
O básico do bash é fácil de aprender. Mas não pare por aí: há uma
incrível profundidade nele. Habitue-se procurar meios melhores de se
fazer as coisas.

<P>
<!--
Read shell scripts, look up stuff you don't understand.
-->
Leia os roteiros shell, procure saber o que não entende.

<SECT1>Mais Informações
<P>
<ITEMIZE>
<ITEM>
<!--
There is a ``Bash Reference Manual'' with this, which is
comprehensive, but heavy going.
-->
Existe um ``Bash Reference Manual'' que é abrangente, porém de difícil
leitura.

<ITEM>
<!--
There is an O'Rielly book on Bash, not sure if it's good.
-->
Existe um livro da O'Rielly sobre o Bash, mas não estou certo se é
bom.

<ITEM>
<!--
I don't know of any good free up to date bash tutorials. If you do,
please email me a url.
-->
Não conheço nenhum bom tutorial gratuito e atualizado sobre o bash. Se
souber, por favor me envie por e-mail uma url.

<ITEM>
<!--
source code, see <URL URL="http://www.netspace.net.au/~gok/power2bash"
NAME="Building a Minimal Linux System from Source Code"> for urls
-->
código fonte, veja <URL URL="http://www.netspace.net.au/~gok/power2bash"
NAME="Building a Minimal Linux System from Source Code"> para
encontrar urls.

</ITEMIZE>



<SECT>Comandos
<P>
<!--
You do most things in bash by issuing commands like <TT>cp</TT>. Most
of these commands are small programs, though some, like <TT>cd</TT>
are built into the shell.
-->
No bash a maioria das coisas é feita por meio de comandos como
<TT>cp</TT>. Quase todos estes comandos são pequenos programas, como
<TT>cd</TT> que está embutido no shell.

<P>
<!--
The commands come in packages, most of them from the Free Software
Foundation (or GNU). Rather than list the packages here, I'll direct
you to the <URL URL="http://www.linuxfromscratch.org" NAME="Linux From
Scratch HOWTO">. It has a full and up to date list of the packages
that go into a Linux system as well as instructions on how to build
them.
-->
Estes comandos vem em pacotes, a maioria da Free Software Foundation
(ou GNU). Em vez de listar estes pacotes aqui, vou te encaminhar para
o <URL URL="http://www.linuxfromscratch.org" NAME="Linux From Scratch
HOWTO">. Este tem uma lista completa e atualizada dos pacotes que vão
em um sistema Linux assim como as instruções de como os construir.



<SECT>Conclusão
<P>
<!--
One of the best things about Linux, in my humble opinion, is that you
can get inside it and really find out how it all works. I hope that
you enjoy this as much as I do. And I hope that this little note has
helped you do it.
-->
Uma das melhores coisas sobre o Linux, em minha humilde opinião, é que
você pode entrar dentro dele e ver como ele realmente funciona. Espero
que tenha gostado tanto quanto eu. E espero também que estas poucas
notas tenham te ajudado.



<SECT>Administrivia


<SECT1>Copyright
<P>
<!--
This document is copyright (c) 1999, 2000 Greg O'Keefe. You are
welcome to use, copy, distribute or modify it, without charge, under
the terms of the <URL URL="http://www.gnu.org/copyleft/gpl.html"
NAME="GNU General Public Licence">. Please acknowledge me if you use
all or part of this in another document.
-->
Os direitos autorais deste documento pertencem à Greg O'Keefe -
Copyright (c) 1999, 2000 Greg O'Keefe. Você pode usar, copiar,
distribuir ou modificar isto, sem ônus, sob os termos da <URL
URL="http://www.gnu.org/copyleft/gpl.html" NAME="GNU General Public
Licence">. Por favor, me cite como autor se usar todo ou partes deste
documento em outro documento.


<SECT1>Página Web
<P>
<!--
The lastest version of this document lives at <URL
URL="http://www.netspace.net.au/~gok/power2bash" NAME="From Powerup To
Bash Prompt"> as does its companion ``Building a Minimal Linux System
from Source Code''.
-->
A versão mais recente deste documento está em <URL
URL="http://www.netspace.net.au/~gok/power2bash" NAME="From Powerup To
Bash Prompt"> assim como seu companheiro ``Building a Minimal Linux
System from Source Code''.

<P>
<!--
There is a French translation at <URL
URL="http://www.freenix.fr/unix/linux/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html"
NAME="From Powerup To Bash Prompt"> thanks to Dominique van den
Broeck. A Japanese by Yuji Senda is coming soon, if it's not at <URL
URL="http://www.linux.or.jp/JF" NAME="Japanese Documentation and FAQ
Project"> already.
-->
Há uma tradução para o Francês em <URL
URL="http://www.freenix.fr/unix/linux/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html"
NAME="From Powerup To Bash Prompt"> obrigado a Dominique van den
Broeck. Logo haverá uma para o Japonês feita por Yuji Senda, se não já
estiver pronta em <URL URL="http://www.linux.or.jp/JF" NAME="Japanese
Documentation and FAQ Project">

<SECT1>Retorno <!-- Feedback -->
<P>
<!--
I would like to hear any comments, criticisms and suggestions for
improvement that you have. Please send them to me <URL
URL="mailto:gcokeefe@postoffice.utas.edu.au" NAME="Greg O'Keefe">
-->
Gostaria de ouvir quaisquer comentários, críticas ou sugestões de
melhoras que você tenha. Por favor, envie-as para <URL
URL="mailto:gcokeefe@postoffice.utas.edu.au" NAME="Greg O'Keefe">

<SECT1>Agradecimentos
<LABEL ID="acknowledge">
<P>
<!--
Product names are trademarks of the respective holders, and are hereby
considered properly acknowledged.
-->
Os nome de produtos são marcas registradas de seus respectivos
proprietários, e por meio disto considerado adequadamente
reconhecidos. <!-- ?? -->

<P>
<!--
There are some people I want to say thanks to, for helping to make
this happen.
-->
Existem algumas pessoas que quero agradecer, por ajudar que isto
acontecesse.

<P>
<DESCRIP>
	
<TAG>Michael Emery</TAG>
<!-- For reminding me about Unios. -->
Por me lembrar sobre o Unios

<TAG>Tim Little</TAG>
<!-- For some good clues about <TT>/etc/passwd</TT> -->
Por várias boas dicas sobre <TT>/etc/passwd</TT>

<TAG>sPaKr on #linux in efnet</TAG>
<!--
Who sussed out that syslogd needs <TT>/etc/services</TT>, 
and introduced me to the phrase ``rolling your own'' to 
describe building a system from source code.
-->
Quem me avisou que o syslogd precisa de <TT>/etc/services</TT>, e me
apresentou a frase ``rolling your own'' para descrever a construção de
um sistema a partir do código fonte.

<TAG>Alex Aitkin</TAG>
<!--
For bringing Vico and his ``verum ipsum factum'' 
(understanding arises through making) to my attention.
-->
Por me chamar a atenção sobre Vico e seu ``verum ipsum factum'' (o
conhecimento vem pela prática).

<TAG>Dennis Scott</TAG>
<!-- For correcting my hexidecimal arithmetic. -->
Por corrigir minha aritimética hexadecimal.

<TAG>jdd</TAG>
<!-- For pointing out some typos. -->
Por me mostrar alguns erros tipográficos.

<TAG>David Leadbeater</TAG>
<!-- For contributing some ``ramblings'' about the kernel deamons. -->
Por contribuir com vários assuntos ``tortuosos'' sobre os daemons do
kernel.

<TAG>Dominique van den Broeck </TAG>
<!-- For translating this doc into French. -->
Por traduzir este documento para o Francês.

<TAG>Matthieu Peeters </TAG>
<!-- For some good information about kernel deamons. -->
Por várias boas informações sobre os daemons do kernel.

<TAG>John Fremlin</TAG>
<!-- For some good information about kernel deamons. -->
Por várias boas informações sobre os daemons do kernel.

<TAG>Yuji Senda</TAG>
<!-- For the Japanese translation. -->
Pela tradução para o Japonês.

<TAG>Antonius de Rozari</TAG>
<!--
For contributing a GNU assembler version of UNIOS
(see resources section on the home page) 
-->
Por contribuir com uma versão do UNIOS para o montador GNU as (veja a
seção de recursos na página web)

<TAG>Botp Peña</TAG>
<!-- For the ``roll your own os'' link. -->
Pelo link para o ``roll your own os''.

<TAG>Kees J. Bot</TAG>
<!--
Author of the Minix manpages. In particular, the <TT>boot</TT> man
page, which has the subtitle ``boot - from power on to the login
prompt''. I only discovered this little gem after I had written and
submitted the present doc to the LDP.
-->
Autor das páginas de manual do Minix. Em particular, a página de
manual sobre o <TT>boot</TT> que tem o subtítulo ``boot - from power
on to the login prompt'' (de quando é ligado até o login). Apenas
descobri esta pequena pérola depois que escrevi e submeti o documento
atual para o LDP.

<TAG>Scott Hankin</TAG>
For spotting a typo. ??
</DESCRIP>


<SECT1>Histórico de modificações

<SECT2>0.9 -> 0.9a (Novembro 2000)
<P>
<ITEMIZE>
<ITEM>
<!-- Added the roll your own os link to the Hardware section. -->
Adicionado o link ``roll your own os'' à seção Hardware.

</ITEMIZE>

<SECT2>0.8 -> 0.9 (Novembro 2000)
<P>
<ITEMIZE>
<ITEM>
<!--
Incorporated some information from Matthieu Peeters and John Fremlin
on kernel deamons and the <TT>/proc</TT> filesystem.
-->
Incorporada várias informações de Matthieu Peeters e John Fremlin em
daemons do kernel e o sistema de arquivos <TT>/proc</TT>.

</ITEMIZE>

<SECT2>0.7 -> 0.8 (Setembro 2000)
<P>
<ITEMIZE>
<ITEM>
<!--
Removed instructions on how to build a system, placing them in a
separate document. Adjusted a few links accordingly.
-->
Removidas as instruções sobre como construir um sistema, colocando-as
em um documento separado. Ajustado alguns links adequadamente.

<ITEM>
<!--
Changed homepage from <URL
URL="http://learning.taslug.org.au/power2bash" NAME="learning@TasLUG">
to <URL URL="http://www.netspace.net.au/~gok/power2bash" NAME="my own
webspace">.
-->
Movida a página web de <URL
URL="http://learning.taslug.org.au/power2bash" NAME="learning@TasLUG">
para <URL URL="http://www.netspace.net.au/~gok/power2bash" NAME="meu
próprio espaço na web">.

<ITEM>
<!--
Completely failed to incorporate a lot of good material contributed by
various people. Maybe next time :(
-->
Falhei completamente em incorporar um monte de bom material
contribuído por várias pessoas. Talvez da próxima vez :(

</ITEMIZE>

<SECT2>0.6 -> 0.7
<P>
<ITEMIZE>
<ITEM>
<!--
more emphasis on explanation, less on how to build a system, building
info gathered together in a separate section and the system built is
trimmed down, direct readers to Gerard Beekmans' ``Linux From
Scratch'' doc for serious building
-->
Mais ênfase nas explicações, menos em como construir um sistema,
informações de construção reunidas em uma seção separada e reduzida,
encaminhar os leitores para o ``Linux From Scratch'' de Gerard
Beekmans para construções sérias.

<ITEM>
<!--
added some ramblings contributed by David Leadbeater
-->
Adicionada contribuições de David Leadbeater.

<ITEM>
<!--
fixed a couple of url's, added link to unios download at
learning.taslug.org.au/resources
-->
Corrigido um par de urls, adicionado link para baixar o unios em
learning.taslug.org.au/resources.

<ITEM>
<!-- tested and fixed url's -->
Testadas e corrigidas urls.

<ITEM>
<!-- generally rewrite, tidy up -->
Reescrita geral, posto em ordem.
</ITEMIZE>

<SECT2>0.5 -> 0.6
<P>
<ITEMIZE>
<ITEM>
<!-- added change history -->
Adicionado o histórico de modificações.

<ITEM>
<!-- added some todos -->
Adicionada várias tarefas a fazer.
</ITEMIZE>


<SECT1>TODO (Tarefas a fazer)
<P>
<ITEMIZE>
<ITEM>
<!--
explain kernel modules, depmod, modprobe, insmod and all that (I'll
have to find out first!)
-->
Explicar módulos do kernel, depmod, modprobe, insmod e tudo mais (vou
precisar aprender primeiro!).

<ITEM>
<!-- mention the /proc filesystem, potential for exercises here -->
Mencionar o sistema de arquivos /proc, potencial para exercícios.

<ITEM>
<!-- convert to docbook sgml -->
Converter para docbook sgml

<ITEM>
<!--
add more exercises, perhaps a whole section on larger exercises, like
creating a minimal system file by file from a distro install.
-->
Adicionar mais exercícios, talvez uma seção inteira de grandes
exercícios, como criar um sistema de arquivos mínimo com arquivos da
instalação de uma distribuição.

<ITEM>
add makefile hack to bash build instructions - see easter notes. ??

</ITEMIZE>

</ARTICLE>
