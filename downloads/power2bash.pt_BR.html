<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.65">
 <TITLE>De Quando é Ligado até o Bash</TITLE>
</HEAD>
<BODY>
<H1>De Quando é Ligado até o Bash</H1>

<H2>Greg O'Keefe, <CODE>gcokeefe@postoffice.utas.edu.au</CODE></H2>v0.9a, Novembro 2000
<HR>
<EM>Esta é uma breve descrição do que acontece num sistema Linux, de
quando é ligado até o momento em que você se identifica e obtém uma
linha de comandos do bash. Entender isso lhe será útil quando precisar
resolver problemas ou configurar seu sistema.</EM>
<HR>
<H2><A NAME="s1">1. Introdução</A></H2>

<P>Acho frustrante que muitas coisas acontecem em minha máquina Linux que
não entendo. Se você, como eu, também quer realmente entender seu
sistema e não apenas saber como usá-lo, este documento é um bom
começo. Esse tipo de conhecimento também é necessário se você quer se
tornar um solucionador de problemas em Linux de primeira.</P>

<P>Presumo que você tenha uma máquina Linux funcionando, e entende algumas
coisas básicas sobre Unix e hardware de PC. Se não, um excelente ponto
de partida é o 
<A HREF="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html">The Unix and Internet Fundamentals HOWTO</A> de Eric
S. Raymond. É curto, fácil de ler e trata de todos os temas básicos.</P>

<P>O principal tema deste documento é como o Linux se inicializa. Mas
este também tenta ser um recurso de aprendizado mais abrangente. Eu
inclui exercícios em cada seção. Se você fizer alguns destes, irá
aprender muito mais que simplesmente lendo.</P>

<P>Espero que alguns leitores façam o melhor exercício para aprender
Linux que conheço, que é construir um sistema a partir do código
fonte. Giambattista Vico, um filósofo Italiano (1668-1744) disse
``verum ipsum factum'', que significa ``o conhecimento vem pela
prática''. Obrigado ao Alex (ver 
<A HREF="#acknowledge">Agradecimentos</A>) por esta citação.</P>

<P>Se você quer por a mão na massa, veja também o 
<A HREF="http://www.linuxfromscratch.org">Linux From Scratch HOWTO</A>
(LFS) de Gerard Beekman. O LFS tem instruções detalhadas para
construir um sistema usável completo a partir do código fonte. No
sítio do LFS você também vai encontrar uma lista de discussões para
pessoas que estão construindo sistemas dessa forma. As instruções que
faziam parte deste documento agora estão em um documento separado,
``Building a Minimal Linux System from Source Code'', e pode ser
encontrado em 
<A HREF="http://www.netspace.net.au/~gok/power2bash/">From PowerUp to Bash Prompt home page</A>. Elas indicam como
construir um sistema experimental, como um mero exercício de
aprendizagem.</P>

<P>Os pacotes são apresentados na ordem em que eles aparecem no processo
de inicialização do sistema. Isso significa que se você instalar os
pacotes nesta ordem poderá reiniciar após cada instalação e ver o
sistema ir tomando forma, até te fornecer a linha de comandos do
bash. Há uma forte sensação de progresso.</P>

<P>Recomendo primeiro ler o texto principal de cada seção, pulando os
exercícios e referências. Decida então até onde deseja se aprofundar
e quanto de esforço você está disposto a investir. Em seguida volte ao
início, fazendo os exercícios e as leituras adicionais conforme for
avançando.</P>



<H2><A NAME="s2">2. Hardware</A></H2>

<P>Quando você liga o computador, ele faz um teste em si mesmo para
certificar-se de que tudo está funcionando corretamente. Esse teste é
chamado de ``Power on self test''. Em seguida um programa chamado
bootstrap loader, que se encontra na ROM BIOS, procura por um setor de
inicialização. Um setor de inicialização é o primeiro setor em um
disco e tem um pequeno programa capaz de carregar um sistema
operacional. Os setores de inicialização são marcados com um número
mágico 0xAA55 = 43603 no byte 0x1FE = 510. Estes são os dois últimos
bytes do setor. É desta forma que o hardware pode saber se um setor é
um setor de inicialização ou não.</P>

<P>O bootstrap loader tem uma lista de lugares onde procurar por um setor
de inicialização. Minha máquina velha procura no drive primário de
disquete, em seguida no disco rígido primário. Máquinas mais modernas
também podem procurar por um setor de inicialização num CD-ROM. Se
encontrar um setor de inicialização, irá carregá-lo na memória e
passar o controle ao programa que carrega o sistema operacional. Num
sistema Linux típico este programa será o primeiro estágio do
carregador LILO. Existem muitas maneiras diferentes de configurar a
inicialização do seu sistema. Veja o <EM>LILO User's Guide</EM> para
mais detalhes. Na seção 
<A HREF="#lilo-links">LILO</A> há uma URL.</P>

<P>Obviamente há muito mais pra dizer sobre o que o hardware dum PC
faz, mas este não é o lugar para isto. Veja um dos muitos bons livros
sobre hardware de PC.</P>


<H2><A NAME="ss2.1">2.1 Configuração</A>
</H2>

<P>A máquina armazena alguma informação sobre si mesma em sua CMOS. Isto
inclui quais discos e RAM existem no sistema. A BIOS da máquina contém
um programa que permite a você modificar estas configurações. Veja a
mensagem na tela de sua máquina quando é ligada para verificar como
acessá-la. Em minha máquina se pressiona a tecla delete antes que ela
comece a carregar o sistema operacional.</P>


<H2><A NAME="hardware-ex"></A> <A NAME="ss2.2">2.2 Exercícios </A>
</H2>

<P>Um bom jeito de aprender sobre o hardware do PC é montar uma máquina
com componentes de segunda mão. Use pelo menos um 386, assim você
poderá colocar o Linux para rodar facilmente. Não será muito
caro. Pergunte por aí, alguém poderia te dar algumas peças que vais
precisar.</P>

<P>Baixe, compile e faça um disco de inicialização para o 
<A HREF="http://www.netspace.net.au/~gok/resources">Unios</A>. (Eles
tinham uma página em 
<A HREF="http://www.unios.org">http://www.unios.org</A> mas
desapareceu). É um simples programa ``Olá mundo!'', que consiste em
pouco mais de 100 linhas de código assembly. Seria bom vê-lo
convertido a um formato que possa ser entendido pelo montador GNU
<CODE>as</CODE>.</P>

<P>Existem instruções para criar seu próprio sistema operacional em 
<A HREF="http://www.acm.uiuc.edu/sigops/roll_your_own/">Roll Your Own</A> se você quiser um desafio <EM>de verdade</EM>.</P>

<P>Abra a imagem de disco do unios com um editor hexadecimal. Esta imagem
tem 512 bytes, exatamente um setor. Encontre o número mágico
0xAA55. Faça o mesmo para o setor de inicialização dum disquete em seu
próprio computador. Você pode usar o comando <CODE>dd</CODE> para copiar
ele para um arquivo: <CODE>dd if=/dev/fd0 of=boot.sector</CODE>. Seja
<EM>muito</EM> cuidadoso escrevendo <CODE>if</CODE> (input file) e
<CODE>of</CODE> (output file) corretamente!</P>

<P>Veja o código fonte do carregador de sistemas LILO.</P>


<H2><A NAME="ss2.3">2.3 Mais Informações</A>
</H2>

<P>
<UL>
<LI>
<A HREF="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html">The Unix and Internet Fundamentals HOWTO</A> por Eric S. Raymond,
especialmente a seção 3, <EM>What happens when you switch on a
computer?</EM>
</LI>
<LI>O primeiro capítulo do <EM>The LILO User's Guide</EM> tem uma
excelente explicação sobre as partições do disco e a inicialização do
PC. Na seção 
<A HREF="#lilo-links">LILO</A> há uma URL.
</LI>
<LI><EM>The NEW Peter Norton Programmer's Guide to the IBM PC &amp; PS/2</EM>, 
por Peter Norton e Richard Wilton, Microsoft Press 1988. Há um livro
novo do Norton, parece bom, mas agora eu não posso pagar.
</LI>
<LI>Um dos muitos livros disponíveis sobre atualização de PCs.</LI>
</UL>
</P>



<H2><A NAME="s3">3. Lilo</A></H2>

<P>Quando o computador carrega um setor de inicialização em um sistema
Linux normal, o que ele realmente carrega é uma parte do lilo chamado
``first stage boot loader'' (primeiro estágio do carregador). É um
pequeno programa que a única coisa que faz na vida é carregar e rodar
o segundo estágio.</P>

<P>O segundo estágio apresenta uma linha de comandos (se foi instalado
assim) e carrega o sistema operacional que você escolher.</P>

<P>Quando seu sistema está em funcionamento e você roda <CODE>lilo</CODE>, o
que você está realmente rodando é um ``instalador do mapa''. Ele lê o
arquivo de configuração <CODE>/etc/lilo.conf</CODE> e escreve os
carregadores, assim como informações sobre os sistemas operacionais
que ele pode carregar, no disco rígido.</P>

<P>Existem diversas formas de configurar a inicialização de seu
sistema. O que acabo de explicar é a forma mais óbvia e ``normal'',
pelo menos em um sistema onde o principal sistema operacional é o
Linux. O Guia do Usuário do LILO explica vários exemplos de conceitos
de inicialização. Vale a pena ler e tentar alguns deles.</P>


<H2><A NAME="ss3.1">3.1 Configuração</A>
</H2>

<P>O arquivo de configuração para o lilo é <CODE>/etc/lilo.conf</CODE>. Há
uma página de manual para ele: digite <CODE>man lilo.conf</CODE> num
shell para vê-la. O principal no <CODE>lilo.conf</CODE> é uma entrada para
cada sistema operacional que o lilo pode inicializar. Em uma entrada
para Linux inclui onde está o kernel e que partição do disco montar
como raíz. Para outros sistemas operacionais, a informação mais
importante é a partir de qual partição inicializar.</P>


<H2><A NAME="ss3.2">3.2 Exercícios</A>
</H2>

<P><EM>PERIGO:</EM> tome cuidado com estes exercícios. É bastante fácil
fazer algo errado e danificar seu MBR (master boot record - registro
mestre de inicialização) e tornar seu sistema inutilizável.
Certifique-se de ter um disco de recuperação funcionando e saber como
usá-lo para concertar a bagunça. Abaixo há um link para o tomsrtbt, o
disco de recuperação que eu uso e recomendo. A melhor precaução é usar
uma máquina sem importância.</P>

<P>Prepare um disquete com o lilo. Não importa que não há nada além do
kernel no disquete - você verá um ``kernel panic'' quando o kernel
estiver pronto para carregar o init, mas pelo menos você saberá que o
lilo está funcionando.</P>

<P>Se quiser, você pode espremer para ver quanto do sistema você consegue
colocar num disquete. Esta é provavelmente a segunda melhor atividade
para aprender Linux. Veja o Bootdisk HOWTO (url abaixo) e tomsrtbt
(url abaixo) para ter uma idéia.</P>

<P>Faça o lilo inicializar o unios (há uma URL na seção 
<A HREF="#hardware-ex">exercícios de hardware</A>). Como um desafio
extra tente fazer isto num disquete.</P>

<P>Faça um laço de inicializações. Configure o lilo no MBR para
inicializar o lilo no setor de inicialização de uma partição primária,
e este para inicializar o lilo no MBR... Ou talvez usar o MBR e todas
as quatro partições primárias, fazendo um laço de cinco
pontos. Divirta-se!</P>

<H2><A NAME="ss3.3">3.3 Mais Informações</A>
</H2>

<P>
<A NAME="lilo-links"></A> 
<UL>
<LI>A página de manual do lilo.
</LI>
<LI>O pacote Lilo (
<A HREF="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/">lilo</A>),
contém o ``LILO User's Guide''<CODE>lilo-u-21.ps.gz</CODE> (ou outra
versão mais recente). É provável que você já tenha este
documento. Tente em <CODE>/usr/doc/lilo</CODE> ou algo parecido. A versão
postscript é melhor que a de texto simples, já que contém diagramas e
tabelas.
</LI>
<LI>
<A HREF="http://www.toms.net/rb">tomsrtbt</A> o melhor linux em
um só disquete. Excelente como disco de recuperação.
</LI>
<LI>
<A HREF="http://www.linuxdoc.org/HOWTO/Bootdisk-HOWTO/">The Bootdisk HOWTO</A>
</LI>
</UL>
</P>



<H2><A NAME="s4">4. O Kernel do Linux</A></H2>

<P>Na verdade o kernel faz muitas coisas. Creio que uma boa forma de
resumir é que ele faz o hardware fazer o que os programas querem, de
forma clara e eficiente.</P>

<P>O processador pode executar apenas uma instrução de cada vez, mas os
sistemas Linux parecem fazer várias coisas simultaneamente. O kernel
consegue isto alternando de uma tarefa à outra rapidamente. Ele faz
um melhor uso do processador rastreando quais processos estão prontos
e quais estão esperando por algo como um registro num arquivo do disco
rígido ou uma entrada do teclado. Esta tarefa do kernel é chamada de
scheduling (agendamento). </P>

<P>Se um programa não está fazendo nada, não precisa estar na RAM. Mesmo
um programa que está fazendo algo pode ter partes que não estão
fazendo nada. O espaço de endereçamento de cada processo está dividido
em páginas. O kernel verifica quais páginas estão sendo usadas mais
freqüentemente. As páginas que não estão sendo muito usadas podem ser
retiradas para a partição de troca (swap). Quando elas forem
necessárias novamente, pode se retirar outra página pouco usada para
desocupar-lhe espaço. Este é o gerenciamento de memória virtual.</P>

<P>Se alguma vez você já compilou seu próprio Kernel, você deve ter
notado que existem muitas opções para dispositivos específicos. O
kernel contém muito código específico para comunicar com os diversos
tipos de hardware, e apresentá-los de uma maneira uniforme aos
aplicativos.</P>

<P>O Kernel também gerencia o sistema de arquivos, a comunicação entre os
processos, e um monte de coisas relacionadas à redes.</P>

<P>Uma vez que o kernel for carregado, a primeira coisa que ele faz é
procurar por um programa <CODE>init</CODE> para executar.</P>

<H2><A NAME="ss4.1">4.1 Configuração</A>
</H2>

<P>A maior parte da configuração do kernel é feita quando o estiver
construindo, usando <CODE>make menuconfig</CODE>, ou <CODE>make xconfig</CODE>
em <CODE>/usr/src/linux/</CODE> (ou onde quer que esteja o código fonte do
kernel do seu Linux). Você pode redefinir o modo de vídeo padrão, o
sistema de arquivos raíz, o dispositivo de troca (swap) e o tamanho do
disco em RAM usando <CODE>rdev</CODE>. Estes e outros parâmetros podem ser
passados ao kernel pelo lilo. Você pode dar ao lilo os parâmetros para
passar ao kernel tanto no lilo.conf quanto na linha de comandos do
lilo. Por exemplo, se quiser usar hda3 como seu sistema de arquivos
raíz em vez de hda2, poderia digitar:</P>
<P>
<PRE>
        LILO: linux root=/dev/hda3
</PRE>
</P>

<P>Se estiver construindo um sistema a partir do código fonte, será bem
mais fácil criar um kernel ``monolítico'', ou seja, sem módulos. Assim
não irá precisar copiar os módulos para o sistema de destino.</P>

<P>NOTA: O agente de log do kernel usa o arquivo <CODE>System.map</CODE> para
determinar os nomes dos módulos gerando mensagens. O programa
<CODE>top</CODE> também usa esta informação. Quando copiar o kernel para o
sistema de destino, copie também <CODE>System.map</CODE>.</P>

<H2><A NAME="ss4.2">4.2 Exercícios</A>
</H2>

<P>Pense nisto: <CODE>/dev/hda3</CODE> é um tipo especial de arquivo que
descreve uma partição do disco rígido. Mas ele está num sistema de
arquivos exatamente como todos os outros arquivos. O kernel quer saber
qual partição montar como sistema de arquivos raíz - ele ainda não tem
um sistema de arquivos. Então como ele pode ler <CODE>/dev/hda3</CODE>
para saber qual partição montar?</P>

<P>Se ainda não o fez: construa seu próprio kernel. Leia toda a
informação de ajuda para cada opção.</P>

<P>Tente fazer o menor kernel funcional possível. Você pode aprender
bastante quando as coisas derem errado!</P>

<P>Leia ``The Linux Kernel'' (URL abaixo) e veja se pode encontrar as
partes do código fonte a qual ele se refere. O livro (no momento em
que escrevo) usa a versão 2.0.33 do kernel, que está obsoleta. Será
mais fácil se baixar esta versão antiga e ler estes fontes. É
surpreendente encontrar coisas no código C chamados ``process'' e
``page''.</P>

<P>Fuce! Veja se consegue fazer ele mostrar umas mensagens extras ou
qualquer outra coisa.</P>

<H2><A NAME="Kernel"></A> <A NAME="ss4.3">4.3 Mais Informações </A>
</H2>

<P>
<UL>
<LI><CODE>/usr/src/linux/README</CODE> e o conteúdo de
<CODE>/usr/src/linux/Documentation/</CODE> (eles podem estar em algum
outro lugar em seu sistema)
</LI>
<LI>
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Kernel-HOWTO.html">The Kernel HOWTO</A>
</LI>
<LI>A ajuda disponível ao configurar um kernel usando <CODE>make
menuconfig</CODE> ou <CODE>make xconfig</CODE>
</LI>
<LI>
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">The Linux Kernel (e outros guias LDP)</A>
</LI>
<LI>código fonte, veja 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> para encontrar urls
</LI>
</UL>
</P>



<H2><A NAME="s5">5. A Biblioteca GNU C</A></H2>

<P>A próxima coisa que acontece quando seu computador é inicializado é
carregar e rodar o init. Porém, o init, como quase todos programas,
usa funções de bibliotecas.</P>

<P>Você já deve ter visto um programa de exemplo em C como este:</P>

<P>
<PRE>
        main() {
                printf("Hello World!\n");
        }
</PRE>
</P>
<P>O programa não contém a definição de <CODE>printf</CODE>, então de onde
ela vem? Ela vem das bibliotecas C padrão, num sistema GNU/Linux,
glibc. Se for compilado com o Visual C++, então será a implementação
da Microsoft das mesmas funções padrão. Existem zilhões destas funções
padrão, para matemática, string, data e hora, alocação de memória, e
assim por diante. Tudo no Unix (incluindo Linux) é escrito em C ou se
esforça em fingir que o é, portanto tudo usa estas funções.</P>

<P>Se você olhar em <CODE>/lib</CODE> em seu sistema linux, verá arquivos
chamados <CODE>libqualquercoisa.so</CODE> ou <CODE>libqualquercoisa.a</CODE>
aos montes. São as bibliotecas destas funções. Glibc é apenas a
implementação GNU destas funções.</P>

<P>Existem duas formas pelas quais os programas podem usar estas funções
de bibliotecas. Se vincular <EM>estaticamente</EM>, estas funções de
bibliotecas serão copiadas no executável que será criado. Para isso
que servem as bibliotecas <CODE>libqualquercoisa.a</CODE>. Se vincular
<EM>dinamicamente</EM> (e este é o padrão), então quando estiver
rodando e precisar do código da biblioteca, ele será chamado a partir
do arquivo <CODE>libqualquercoisa.so</CODE>.</P>

<P>O comando <CODE>ldd</CODE> é seu amigo quando quiser saber quais
bibliotecas são necessárias à um programa em particular. Por exemplo,
aqui estão as bibliotecas que o <CODE>bash</CODE> usa:</P>

<P>
<PRE>
        [greg@Curry power2bash]$ ldd /bin/bash
                libtermcap.so.2 => /lib/libtermcap.so.2 (0x40019000)
                libc.so.6 => /lib/libc.so.6 (0x4001d000)
                /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</PRE>
</P>

<H2><A NAME="ss5.1">5.1 Configuração</A>
</H2>

<P>Algumas das funções das bibliotecas dependem de onde você está. Por
exemplo, na Austrália nós escrevemos as datas como dd/mm/aa, mas os
Americanos escrevem mm/dd/aa. Existe um programa que acompanha a
distribuição da <CODE>glibc</CODE> chamado <CODE>localedef</CODE> que te
permite definir isso.</P>


<H2><A NAME="ss5.2">5.2 Exercícios</A>
</H2>

<P>Use o <CODE>ldd</CODE> para verificar quais bibliotecas seus aplicativos
favoritos usam.</P>

<P>Use o <CODE>ldd</CODE> para verificar quais bibliotecas o <CODE>init</CODE>
usa.</P>

<P>Faça uma biblioteca de testes, apenas com uma ou duas funções. O
programa <CODE>ar</CODE> é usado para criá-las, a página de manual para o
<CODE>ar</CODE> pode ser um bom lugar para começar a investigar como isto
é feito. Escreva, compile e vincule um programa que use esta
biblioteca.</P>


<H2><A NAME="ss5.3">5.3 Mais Informações</A>
</H2>

<P>
<UL>
<LI>código fonte, veja 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> para encontrar urls</LI>
</UL>
</P>



<H2><A NAME="s6">6. Init</A></H2>

<P>Vou falar apenas sobre o init estilo ``System V'' que é majoritário
nos sistemas Linux. Existem alternativas. De fato, você pode pôr
qualquer programa que queira em <CODE>/sbin/init</CODE>, e o kernel vai
rodá-lo assim que terminar de carregar.</P>

<P>É tarefa do <CODE>init</CODE> pôr tudo para funcionar de forma
apropriada. Ele verifica se os sistemas de arquivos estão corretos e
os montam. Inicializa os ``daemons'' para registrar as mensagens do
sistema, redes, servir páginas web, escutar o mouse e tudo
mais. Também inicializa os processos ``getty'' que colocam as linhas
de comandos (prompt) de login em seus terminais virtuais.</P>

<P>Há um contexto muito complicado que aborda a alternância entre níveis
de execução (run-levels), mas vou pular a maior parte disso e vou falar
apenas sobre a inicialização do sistema.</P>

<P>O init lê o arquivo <CODE>/etc/inittab</CODE>, que lhe diz o que
fazer. Tipicamente, a primeira coisa que lhe é instruída a fazer é
rodar o roteiro (script) de inicialização. O programa que executa (ou
interpreta) este roteiro é o <CODE>bash</CODE>, o mesmo programa que te
fornece a linha de comandos. Em sistemas Debian, o roteiro de
inicialização é <CODE>/etc/init.d/rcS</CODE>, no Red Hat é
<CODE>/etc/rc.d/rc.sysinit</CODE>. Este é o local onde os sistemas de
arquivos são checados e montados, o relógio é ajustado, os espaços de
troca (swap) habilitados, o nome da máquina é definido, etc.</P>

<P>Depois chama outro roteiro que nos dá o nível de execução padrão, que é
apenas inicializar um conjunto de subsistemas. Existe um conjunto de
diretórios <CODE>/etc/rc.d/rc0.d</CODE>, <CODE>/etc/rc.d/rc1.d</CODE>, ...,
<CODE>/etc/rc.d/rc6.d</CODE> no Red Hat, ou <CODE>/etc/rc0.d</CODE>,
<CODE>/etc/rc1.d</CODE>, ..., <CODE>/etc/rc6.d</CODE> no Debian, que
correspondem aos níveis de execução. Se formos para o nível de
execução 3 num sistema Debian, então o roteiro roda todos os roteiros
em <CODE>/etc/rc3.d</CODE> que começam com `S' (de start). Estes scripts
são apenas vínculos para os roteiros em outro diretório, normalmente
chamado <CODE>init.d</CODE>.</P>

<P>Portanto nosso roteiro de nível de execução é chamado <CODE>init</CODE>, e
está procurando num diretório por roteiros começando com `S'. Talvez
encontre primeiro <CODE>S10syslog</CODE>. Os números dizem ao roteiro de
nível de execução qual a ordem em que devem ser executados. Neste caso
<CODE>S10syslog</CODE> é o primeiro, porque não existem roteiros começando
com S00 .. S09. Porém <CODE>S10syslog</CODE> é na verdade um vínculo para
<CODE>/etc/init.d/syslog</CODE>, que é o roteiro para iniciar e parar o
agente de log do sistema. O roteiro de nível de execução sabe que deve
executar o roteiro <CODE>syslog</CODE> com o parâmetro ``start'' porque o
vínculo começa com `S'. Existem os vínculos correspondentes começando
com `K' (de kill), que especificam o que terminar e em que ordem
quando estivermos saindo do nível de execução.</P>

<P>Para modificar quais subsistemas iniciar por padrão, defina os
vínculos no diretório <CODE>rcN.d</CODE>, onde N é o nível de execução
padrão em seu <CODE>inittab</CODE>.</P>

<P>A última coisa importante que o init faz é iniciar alguns
<CODE>getty</CODE>. Se algum deles parar, é ``recriado'' pelo
<CODE>init</CODE>. A maioria das distribuições vem com seis terminais
virtuais. Você pode querer menos para economizar memória, ou mais para
ter muitas coisas rodando ao mesmo tempo e visualizá-las quando for
necessário rapidamente. Você pode querer também executar um
<CODE>getty</CODE> para um terminal modo texto ou uma discagem em
modem. Nesse caso você devera editar o arquivo <CODE>inittab</CODE>.</P>

<H2><A NAME="ss6.1">6.1 Configuração</A>
</H2>

<P><CODE>/etc/inittab</CODE> é o arquivo de configuração de mais alto nível
para o init.</P>

<P>Os diretórios <CODE>rcN.d</CODE>, onde N = 0, 1, ..., 6 determinam quais
subsistemas serão inicializados.</P>

<P>Em algum lugar num dos roteiros invocados pelo init, aparecerá o comando
<CODE>mount -a</CODE>. Isto significa montar todos os sistemas arquivos
que devem ser montados. O arquivo <CODE>/etc/fstab</CODE> define o que
deve ser montado. Se quiser mudar o que será montado quando seu
sistema inicializar, é este arquivo que você deve editar. Há uma
página de manual para o <CODE>fstab</CODE>.</P>

<H2><A NAME="ss6.2">6.2 Exercícios</A>
</H2>

<P>Encontre o diretório <CODE>rcN.d</CODE> para o nível de execução padrão de
seu sistema e digite <CODE>ls -l</CODE> para ver para quais arquivos os
vínculos apontam.</P>

<P>Modifique o número de gettys que o seu sistema roda.</P>

<P>Remova qualquer subsistema desnecessário do seu nível de execução
padrão.</P>

<P>Veja o quanto você pode reduzir a inicialização.</P>

<P>Prepare um disquete com o lilo, um kernel e um programa ``olá mundo''
vinculado estaticamente chamado <CODE>/sbin/init</CODE> e veja ele
inicializar e dizer olá.</P>

<P>Observe atenciosamente a inicialização de seu sistema e tome notas
sobre o que ele diz estar acontecendo. Ou imprima uma seção do
log do seu sistema <CODE>/var/log/messages</CODE> desde o momento da
inicialização. Então começando pelo <CODE>inittab</CODE>, siga todos os
roteiros e veja o que faz cada código. Você também pode colocar
mensagens de inicialização extras nele, como por exemplo:</P>
<P>
<PRE>
        echo "Olá, sou o rc.sysinit"
</PRE>
</P>
<P>Este também é um bom exercício para aprender escrever roteiros de Bash,
alguns dos roteiros são bastante complicados. Tenha um bom guia de
referência do Bash a mão.</P>


<H2><A NAME="ss6.3">6.3 Mais Informações</A>
</H2>

<P>
<UL>
<LI>Existem páginas de manual para os arquivos <CODE>inittab</CODE> e
<CODE>fstab</CODE>. Digite (por exemplo) <CODE>man inittab</CODE> num shell
para vê-las.
</LI>
<LI>The Linux System Administrators Guide tem uma boa 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">seção</A> sobre o
init.
</LI>
<LI>código fonte, veja
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> para encontrar urls
</LI>
</UL>
</P>



<H2><A NAME="s7">7. O sistema de arquivos</A></H2>

<P>Nesta seção, estarei usando a expressão ``sistema de arquivos'' de
duas formas diferentes. Existem sistemas de arquivos em partições do
disco ou outros dispositivos, e existe o sistema de arquivos como lhe
é apresentado pelo sistema Linux em funcionamento. No Linux, você
``monta'' um sistema de arquivos em disco no sistema de arquivos do
sistema.</P>

<P>Na seção anterior mencionei que os roteiros do init verificam e montam
sistemas de arquivos. Os comandos que fazem isso são <CODE>fsck</CODE> e
<CODE>mount</CODE> respectivamente.</P>

<P>Um disco rígido é apenas um grande espaço onde você pode escrever
zeros e uns. Um sistema de arquivos impõe certa estrutura nisto,
fazendo parecer que existem arquivos em seus diretórios e estes em
seus diretórios... Cada arquivo é representado por um inode, que diz a
quem pertence o arquivo, quando foi criado e onde encontrar seu
conteúdo. Diretórios também são representados por inodes, mas estes
dizem onde encontrar os inodes dos arquivos que estão no diretório. Se
o sistema quer ler <CODE>/home/greg/bigboobs.jpeg</CODE>, primeiro ele
encontra o inode para o diretório raíz <CODE>/</CODE> no ``superbloco'',
em seguida encontra o inode para o diretório <CODE>home</CODE> no conteúdo
de <CODE>/</CODE>, depois encontra o inode para o diretório <CODE>greg</CODE>
no conteúdo de <CODE>/home</CODE>, finalmente o inode para
<CODE>bigboobs.jpeg</CODE> que irá dizer quais blocos do disco ler.</P>

<P>Se acrescentarmos algum dado ao fim do arquivo, pode acontecer dos
dados serem escritos antes do inode ser atualizado para dizer quais os
novos blocos pertencem ao arquivo, ou vice versa. Se houver um corte
de energia neste ponto, o sistema de arquivos estará corrompido. É
este tipo de coisa que o <CODE>fsck</CODE> tenta detectar e reparar.</P>

<P>O comando mount pega um sistema de arquivos num dispositivo, e
o acrescenta à hierarquia que você vê quando usa seu
sistema. Normalmente, o kernel monta o sistema de arquivos raíz
somente para leitura. O comando mount é usado para remontá-lo para
leitura e escrita depois que o <CODE>fsck</CODE> verificou que está tudo
bem.</P>

<P>O Linux também suporta outros tipos de sistema de arquivos: msdos,
vfat, minix e outros mais. Os detalhes de um tipo específico de
sistema de arquivos são abstraídos pelo sistema de arquivos virtual
(VFS). Não vou entrar em detalhes sobre isto. Existe uma discussão
sobre isso no ``The Linux Kernel'' (há uma URL na seção 
<A HREF="#Kernel">O Kernel do Linux</A>).</P>

<P>Um tipo de sistema de arquivos completamente diferente é montado em
<CODE>/proc</CODE>. É na verdade uma representação das coisas no
kernel. Há um diretório ali para cada processo rodando no sistema,
onde o número do processo é o nome do diretório. Também existem
arquivos como <CODE>interrupts</CODE> e <CODE>meminfo</CODE> que dizem sobre
como o hardware está sendo usado. Você pode aprender bastante ao
explorar <CODE>/proc</CODE>.</P>

<H2><A NAME="ss7.1">7.1 Configuração</A>
</H2>

<P>Existem parâmetros para o comando <CODE>mke2fs</CODE> que cria sistemas de
arquivos ext2. Estes controlam o tamanho dos blocos, o número de
inodes, e assim por diante. Veja a página de manual do <CODE>mke2fs</CODE>
para mais detalhes.</P>

<P>O que é montado em seu sistema de arquivos é controlado pelo arquivo
<CODE>/etc/fstab</CODE>. Também há uma página de manual para ele.</P>

<H2><A NAME="ss7.2">7.2 Exercícios</A>
</H2>

<P>Faça um sistema de arquivos bem pequeno, e visualize-o com um
visualizador hexadecimal. Identifique o superbloco, os inodes e o
conteúdo dos arquivos.</P>

<P>Acredito que existam ferramentas que te dão uma visão gráfica do
sistema de arquivos. Encontre uma, teste, e me mande um e-mail com a
url e comentários.</P>

<P>Veja o código do kernel para o sistema de arquivos ext2.</P>

<H2><A NAME="ss7.3">7.3 Mais Informações</A>
</H2>

<P>
<UL>
<LI>O capítulo 9 do livro LDP ``The Linux Kernel'' tem uma excelente
descrição dos sistemas de arquivos. Você pode encontrá-lo no 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">espelho</A>
Australiano do LDP.
</LI>
<LI>O comando <CODE>mount</CODE> é parte do pacote util-linux; há uma URL em
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A>
</LI>
<LI>Páginas de manual para o <CODE>mount</CODE>, <CODE>fstab</CODE>,
<CODE>fsck</CODE>, <CODE>mke2fs</CODE> e <CODE>proc</CODE>.
</LI>
<LI>O arquivo <CODE>Documentation/proc.txt</CODE> no código fonte do Linux
explica o sistema de arquivos <CODE>/proc</CODE>.
</LI>
<LI>A página do EXT2 File System Utilities 
<A HREF="http://web.mit.edu/tytso/www/linux/e2fsprogs.html">ext2fsprogs</A> e o 
<A HREF="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/filesystems/ext2/">espelho</A> Australiano. Há ali um documento Ext2fs-overview,
porém está obsoleto e não é tão legível quanto o capítulo nove do
``The Linux Kernel''.
</LI>
<LI>
<A NAME="FHS"></A> 
<A HREF="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/">Unix File System Standard</A> (outro 
<A HREF="http://www.pathname.com/fhs/">link</A>). Este descreve o que
deve ter em um sistema de arquivos Unix e por que. Também os
requisitos mínimos para <CODE>/bin</CODE>, <CODE>/sbin</CODE> e outros. Esta é
uma boa referência se seu objetivo é criar um sistema mínimo porém
completo.
</LI>
</UL>
</P>



<H2><A NAME="s8">8. Daemons do Kernel</A></H2>

<P>Ao executar o comando <CODE>ps aux</CODE>, verá algo semelhante a isto:</P>

<P>
<PRE>
USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
root         1  0.1  8.0  1284   536   ? S    07:37   0:04 init [2] 
root         2  0.0  0.0     0     0   ? SW   07:37   0:00 (kflushd)
root         3  0.0  0.0     0     0   ? SW   07:37   0:00 (kupdate)
root         4  0.0  0.0     0     0   ? SW   07:37   0:00 (kpiod)
root         5  0.0  0.0     0     0   ? SW   07:37   0:00 (kswapd)
root        52  0.0 10.7  1552   716   ? S    07:38   0:01 syslogd -m 0 
root        54  0.0  7.1  1276   480   ? S    07:38   0:00 klogd 
root        56  0.3 17.3  2232  1156   1 S    07:38   0:13 -bash 
root        57  0.0  7.1  1272   480   2 S    07:38   0:01 /sbin/agetty 38400 tt
root        64  0.1  7.2  1272   484  S1 S    08:16   0:01 /sbin/agetty -L ttyS1
root        70  0.0 10.6  1472   708   1 R   Sep 11   0:01 ps aux 
</PRE>
</P>

<P>Esta é a lista de processos rodando no sistema. A informação é dada
pelo sistema de arquivos <CODE>/proc</CODE>, que mencionei na seção
anterior. Note que o <CODE>init</CODE> é o processo número um. Os
processos dois, três, quatro e cinco são kflushd, kupdate, kpiod e
kswapd. Contudo há algo estranho aqui: note que tanto na coluna do
tamanho do armazenamento virtual (SIZE) quanto o tamanho do
armazenamento real (Real Storage Size, RSS) estes processos tem
zeros. Como pode um processo não usar memória?</P>

<P>Estes processos são daemons do kernel. A maior parte do kernel não é
mostrada na lista de processos, e você apenas poderá calcular quanta
memória ele está usando subtraindo a memória disponível da que há em
seu sistema. Os daemons do kernel são iniciados após o init, portanto
recebem PID's (números de processo) assim como processos
normais. Porém, seu código e dados residem na parte de memória do
kernel.</P>

<P>A coluna de comando está entre parênteses porque o sistema de arquivos
<CODE>/proc</CODE> não tem a informação da linha de comandos para estes
processos.</P>

<P>Então para que servem estes daemons do kernel? Versões anteriores
deste documento tinha um pedido de ajuda, já que eu não sei muito
sobre os daemons do kernel. A história parcial que segue foi feita com
pedaços das várias respostas deste pedido, pelas quais eu sou muito
grato. Mais dicas, referências e correções são bem-vindas!</P>

<P>A entrada e a saída é feita através de <EM>buffers</EM> na
memória. Isto permite as coisas rodarem mais rápido. O que os
programas escrevem pode ser mantido na memória, num buffer, depois
escrito para o disco em pedaços maiores e mais eficientes. Os daemons
<CODE>kflushd</CODE> e <CODE>kupdate</CODE> controlam esta tarefa:
<CODE>kupdate</CODE> roda periodicamente (5 segundos?) para verificar
se existe algum buffer cheio. Se existir, faz com que <CODE>kflushd</CODE>
o escreva para o disco.</P>

<P>Muitas vezes os processos não tem nada para fazer, e os que estão
rodando às vezes não precisam ter todo o seu código na memória. Isto
significa que podemos fazer melhor uso da memória retirando as partes
não usadas dos programas em execução para a(s) partição(s) de troca
(swap) do disco rígido. Mover estes dados para dentro e para fora da
memória quando necessário é feito pelo <CODE>kpiod</CODE> e
<CODE>kswapd</CODE>. Mais ou menos a cada segundo, <CODE>kswapd</CODE> acorda
para verificar a situação da memória, e se alguma coisa no disco é
necessária na memória ou não há memória livre suficiente,
<CODE>kpiod</CODE> é chamado.</P>

<P>Também pode haver o daemon <CODE>kapmd</CODE> rodando em seu sistema se
você configurou o gerenciamento automático de energia em seu kernel.</P>

<H2><A NAME="ss8.1">8.1 Configuração</A>
</H2>

<P>O programa <CODE>update</CODE> te permite configurar o <CODE>kflushd</CODE> e
<CODE>kswapd</CODE>. Experimente <CODE>update -h</CODE> para mais informações.</P>

<P>O espaço de troca é ativado por <CODE>swapon</CODE> e desativado por
<CODE>swapoff</CODE>. O roteiro do init (<CODE>/etc/rc.sysinit</CODE> ou
<CODE>/etc/rc.d/rc.sysinit</CODE>) normalmente chama <CODE>swapon</CODE>
quando o sistema inicializa. Me disseram que <CODE>swapoff</CODE> é útil
para economizar energia nos portáteis.</P>

<H2><A NAME="ss8.2">8.2 Exercícios</A>
</H2>

<P>Execute <CODE>update -d</CODE>, note a frase  na última linha
sobre ``threshold for buffer fratricide'' (limite para o fratricídio do
buffer). Aqui está um conceito intrigante, investigue!</P>

<P>Vá ao diretório <CODE>/proc/sys/vm</CODE> e visualize os arquivos ali com
o <CODE>cat</CODE>. Veja se consegue entender.</P>

<H2><A NAME="ss8.3">8.3 Mais Informações</A>
</H2>

<P>``The Linux Kernel'' de The Linux Documentation Project (veja a seção
<A HREF="#Kernel">O Kernel do Linux</A> para encontrar uma url)</P>

<P>O código fonte do kernel do Linux, se você for corajoso suficiente. O
código do <CODE>kswapd</CODE> está em <CODE>linux/mm/vmscan.c</CODE>, e
<CODE>kflushd</CODE> e <CODE>kupdate</CODE> estão em
<CODE>linux/fs/buffer.c</CODE>.</P>



<H2><A NAME="s9">9. O agente de log do sistema</A></H2>

<P>O init inicializa os daemons <CODE>syslogd</CODE> e o <CODE>klogd</CODE>. Eles
escrevem as mensagens para logs. As mensagens do kernel são
manipuladas pelo <CODE>klogd</CODE>, enquanto o <CODE>syslogd</CODE> manipula
as mensagens de outros processos. O registro de log principal é
<CODE>/var/log/messages</CODE>. Quando alguma coisa está errada, este é um
bom lugar para procurar o que é. Muitas vezes existem dicas valiosas
ali.</P>

<H2><A NAME="ss9.1">9.1 Configuração</A>
</H2>

<P>O arquivo <CODE>/etc/syslog.conf</CODE> diz aos agentes de log quais
mensagens registrar e onde. As mensagens são identificadas pelos
serviços de onde se originam e qual nível de prioridade elas têm. Este
arquivo de configuração consiste de linhas que dizem que as mensagens
do serviço x com prioridade y vão para z, onde z é um arquivo, tty,
impressora, uma máquina remota, ou qualquer outra coisa.</P>

<P>NOTA: O syslog exige que o arquivo <CODE>/etc/services</CODE> esteja
presente. O arquivo services aloca portas. Não estou certo se o syslog
precisa de uma porta para poder fazer o registro remotamente, ou se
mesmo o registro local é feito através uma porta, ou se ele usa o
arquivo <CODE>/etc/services</CODE> apenas para converter os nomes dos
serviços que você digita no arquivo <CODE>/etc/syslog.conf</CODE> em
números de portas.</P>

<H2><A NAME="ss9.2">9.2 Exercícios</A>
</H2>

<P>Dê uma olhada no log do seu sistema. Encontre uma mensagem que você
não compreende e descubra o que significa.</P>

<P>Mande todas as mensagens do seu log para um tty. (depois coloque tudo
de volta ao normal)</P>

<H2><A NAME="ss9.3">9.3 Mais Informações</A>
</H2>

<P>
<A HREF="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/">Espelho</A> Australiano do sysklogd</P>



<H2><A NAME="s10">10. Getty e Login</A></H2>

<P>Getty é o programa que te permite efetuar login através de um
dispositivo serial como um terminal virtual, um terminal texto, ou um
modem. Ele mostra a linha de comandos do login. Uma vez que você
introduz seu nome de usuário, o getty o entrega para o <CODE>login</CODE>,
que te pede a senha, a verifica e te fornece um shell.</P>

<P>Existem muitos gettys disponíveis. Algumas distribuições, incluindo a
Red Hat, usam um muito pequeno chamado <CODE>mingetty</CODE> que funciona
apenas com terminais virtuais.</P>

<P>O programa <CODE>login</CODE> é parte do pacote util-linux, que também
contém um getty chamado <CODE>agetty</CODE>, que funciona muito bem. Este
pacote também contém <CODE>mkswap</CODE>, <CODE>fdisk</CODE>, <CODE>passwd</CODE>,
<CODE>kill</CODE>, <CODE>setterm</CODE>, <CODE>mount</CODE>, <CODE>swapon</CODE>,
<CODE>rdev</CODE>, <CODE>renice</CODE>, <CODE>more</CODE> (o programa) e mais
(quer dizer, mais programas). </P>

<H2><A NAME="ss10.1">10.1 Configuração</A>
</H2>

<P>A mensagem que aparece no topo da sua tela com a linha de comandos do
login vem de <CODE>/etc/issue</CODE>. Os gettys geralmente são iniciados
por <CODE>/etc/inittab</CODE>. O login verifica os detalhes sobre o
usuário em <CODE>/etc/passwd</CODE> e, se o sistema tem mascaramento de
senhas, <CODE>/etc/shadow</CODE>.</P>

<H2><A NAME="ss10.2">10.2 Exercícios</A>
</H2>

<P>Crie um <CODE>/etc/passwd</CODE> manualmente. As senhas podem ser nulas, e
mudadas com o programa <CODE>passwd</CODE> uma vez que você efetuar
login. Veja a página de manual para este arquivo, use <CODE>man 5
passwd</CODE> para obter a página de manual para o arquivo ao invés da
página de manual para o programa.</P>



<H2><A NAME="s11">11. Bash</A></H2>

<P>Se você der ao <CODE>login</CODE> uma combinação válida do nome de usuário
e senha, ele irá verificar em <CODE>/etc/passwd</CODE> qual shell te
fornecer. Na maioria dos casos num sistema Linux será o <CODE>bash</CODE>. É
tarefa do <CODE>bash</CODE> ler seus comandos e fazer com que sejam
executados. Ele é simultaneamente uma interface de usuário e um
interpretador de uma linguagem de programação.</P>

<P>Como interface de usuário ele lê seus comandos e os executa se forem
comandos ``internos'' como  <CODE>cd</CODE>, ou procura e executa um
programa se ele for ``externo'' como <CODE>cp</CODE> ou
<CODE>startx</CODE>. Ele também faz coisas excelentes como manter um
histórico dos comandos e o completamento dos nomes de arquivos.</P>

<P>Nós já vimos o <CODE>bash</CODE> em ação como interpretador de linguagem
de programação. Os roteiros que o <CODE>init</CODE> roda para inicializar o
sistema normalmente são roteiros shell, e são executados pelo
<CODE>bash</CODE>. Ter uma verdadeira linguagem de programação junto
com os utilitários habituais do sistema disponíveis na linha de
comandos é uma combinação muito poderosa, se souber o que estiver
fazendo. Por exemplo (modo convencido ativado) outro dia precisei
aplicar um monte de ``remendos'' a um diretório de código fonte. Fui
capaz de fazê-lo usando apenas este comando:</P>
<P>
<PRE>
for f in /home/greg/sh-utils-1.16*.patch; do patch -p0 &lt; $f; done;
</PRE>
</P>

<P>Este comando procura em todos os arquivos em meu diretório pessoal cujos nomes
começam com <CODE>sh-utils-1.16</CODE> e terminam com
<CODE>.patch</CODE>. Para cada arquivo encontrado ele aponta a variável
<CODE>f</CODE> para aquele arquivo e executa os comandos entre <CODE>do</CODE>
e <CODE>done</CODE>. Neste caso havia 11 arquivos para ``remendar'', mas
seria igualmente fácil se houvesse três mil.</P>

<H2><A NAME="ss11.1">11.1 Configuração</A>
</H2>

<P>O arquivo <CODE>/etc/profile</CODE> controla o comportamento do bash para
todo o sistema. O que você colocar aqui irá afetar todo mundo que usa
o bash em seu sistema. Ele fará coisas como adicionar diretórios ao
<CODE>PATH</CODE>, definir sua variável de diretório <CODE>MAIL</CODE>, etc.</P>

<P>O comportamento padrão do teclado muitas vezes deixa muito a
desejar. Na verdade é o readline que manipula isto. O readline é um
pacote separado que manipula interfaces de linha de comandos,
oferecendo o histórico dos comando e o completamento de nomes de
arquivos, assim como algumas características avançadas de edição de
linhas. Está compilado no bash. Por padrão, o readline é configurado
usando o arquivo <CODE>.inputrc</CODE> em seu diretório pessoal. A
variável do bash INPUTRC pode ser usada para substituir isto para o
bash. Por exemplo: no Red Hat 6, <CODE>INPUTRC</CODE> é definida em
<CODE>/etc/profile</CODE> para <CODE>/etc/inputrc</CODE>. Isto significa que
as teclas de retrocesso (backspace), apagar (delete), início (home) e
fim (end) funcionam bem para todo mundo.</P>

<P>Uma vez que o bash leu o arquivo de configuração para todo o sistema,
ele procura pelo seu arquivo de configuração pessoal. Ele procura em
seu diretório pessoal por <CODE>.bash_profile</CODE>, <CODE>.bash_login</CODE>
e <CODE>.profile</CODE>. Ele roda o primeiro que encontrar. Se quiser
mudar a forma que o bash se comporta para você, sem modificar o modo
que se comporta para os outros, faça isto aqui. Por exemplo, muitos
aplicativos usam variáveis de ambiente para controlar seu
funcionamento. Eu tenho a variável <CODE>EDITOR</CODE> definida para
<CODE>vi</CODE> de forma que posso usar o vi no Midnight Commander (um
excelente gerenciador de arquivos no modo console) em vez do seu
próprio editor.</P>

<H2><A NAME="ss11.2">11.2 Exercícios</A>
</H2>

<P>O básico do bash é fácil de aprender. Mas não pare por aí: há uma
incrível profundidade nele. Habitue-se procurar meios melhores de se
fazer as coisas.</P>

<P>Leia os roteiros shell, procure saber o que não entende.</P>

<H2><A NAME="ss11.3">11.3 Mais Informações</A>
</H2>

<P>
<UL>
<LI>Existe um ``Bash Reference Manual'' que é abrangente, porém de difícil
leitura.
</LI>
<LI>Existe um livro da O'Rielly sobre o Bash, mas não estou certo se é
bom.
</LI>
<LI>Não conheço nenhum bom tutorial gratuito e atualizado sobre o bash. Se
souber, por favor me envie por e-mail uma url.
</LI>
<LI>código fonte, veja 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> para
encontrar urls.
</LI>
</UL>
</P>



<H2><A NAME="s12">12. Comandos</A></H2>

<P>No bash a maioria das coisas é feita por meio de comandos como
<CODE>cp</CODE>. Quase todos estes comandos são pequenos programas, como
<CODE>cd</CODE> que está embutido no shell.</P>

<P>Estes comandos vem em pacotes, a maioria da Free Software Foundation
(ou GNU). Em vez de listar estes pacotes aqui, vou te encaminhar para
o 
<A HREF="http://www.linuxfromscratch.org">Linux From Scratch HOWTO</A>. Este tem uma lista completa e atualizada dos pacotes que vão
em um sistema Linux assim como as instruções de como os construir.</P>



<H2><A NAME="s13">13. Conclusão</A></H2>

<P>Uma das melhores coisas sobre o Linux, em minha humilde opinião, é que
você pode entrar dentro dele e ver como ele realmente funciona. Espero
que tenha gostado tanto quanto eu. E espero também que estas poucas
notas tenham te ajudado.</P>



<H2><A NAME="s14">14. Administrivia</A></H2>

<H2><A NAME="ss14.1">14.1 Copyright</A>
</H2>

<P>Os direitos autorais deste documento pertencem à Greg O'Keefe -
Copyright (c) 1999, 2000 Greg O'Keefe. Você pode usar, copiar,
distribuir ou modificar isto, sem ônus, sob os termos da 
<A HREF="http://www.gnu.org/copyleft/gpl.html">GNU General Public Licence</A>. Por favor, me cite como autor se usar todo ou partes deste
documento em outro documento.</P>


<H2><A NAME="ss14.2">14.2 Página Web</A>
</H2>

<P>A versão mais recente deste documento está em 
<A HREF="http://www.netspace.net.au/~gok/power2bash">From Powerup To Bash Prompt</A> assim como seu companheiro ``Building a Minimal Linux
System from Source Code''.</P>

<P>Há uma tradução para o Francês em 
<A HREF="http://www.freenix.fr/unix/linux/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html">From Powerup To Bash Prompt</A> obrigado a Dominique van den
Broeck. Logo haverá uma para o Japonês feita por Yuji Senda, se não já
estiver pronta em 
<A HREF="http://www.linux.or.jp/JF">Japanese Documentation and FAQ Project</A></P>

<H2><A NAME="ss14.3">14.3 Retorno </A>
</H2>

<P>Gostaria de ouvir quaisquer comentários, críticas ou sugestões de
melhoras que você tenha. Por favor, envie-as para 
<A HREF="mailto:gcokeefe@postoffice.utas.edu.au">Greg O'Keefe</A></P>

<H2><A NAME="acknowledge"></A> <A NAME="ss14.4">14.4 Agradecimentos </A>
</H2>

<P>Os nome de produtos são marcas registradas de seus respectivos
proprietários, e por meio disto considerado adequadamente
reconhecidos. </P>

<P>Existem algumas pessoas que quero agradecer, por ajudar que isto
acontecesse.</P>

<P>
<DL>

<DT><B>Michael Emery</B><DD>
<P>Por me lembrar sobre o Unios</P>

<DT><B>Tim Little</B><DD>
<P>Por várias boas dicas sobre <CODE>/etc/passwd</CODE></P>

<DT><B>sPaKr on #linux in efnet</B><DD>
<P>Quem me avisou que o syslogd precisa de <CODE>/etc/services</CODE>, e me
apresentou a frase ``rolling your own'' para descrever a construção de
um sistema a partir do código fonte.</P>

<DT><B>Alex Aitkin</B><DD>
<P>Por me chamar a atenção sobre Vico e seu ``verum ipsum factum'' (o
conhecimento vem pela prática).</P>

<DT><B>Dennis Scott</B><DD>
<P>Por corrigir minha aritimética hexadecimal.</P>

<DT><B>jdd</B><DD>
<P>Por me mostrar alguns erros tipográficos.</P>

<DT><B>David Leadbeater</B><DD>
<P>Por contribuir com vários assuntos ``tortuosos'' sobre os daemons do
kernel.</P>

<DT><B>Dominique van den Broeck </B><DD>
<P>Por traduzir este documento para o Francês.</P>

<DT><B>Matthieu Peeters </B><DD>
<P>Por várias boas informações sobre os daemons do kernel.</P>

<DT><B>John Fremlin</B><DD>
<P>Por várias boas informações sobre os daemons do kernel.</P>

<DT><B>Yuji Senda</B><DD>
<P>Pela tradução para o Japonês.</P>

<DT><B>Antonius de Rozari</B><DD>
<P>Por contribuir com uma versão do UNIOS para o montador GNU as (veja a
seção de recursos na página web)</P>

<DT><B>Botp Peña</B><DD>
<P>Pelo link para o ``roll your own os''.</P>

<DT><B>Kees J. Bot</B><DD>
<P>Autor das páginas de manual do Minix. Em particular, a página de
manual sobre o <CODE>boot</CODE> que tem o subtítulo ``boot - from power
on to the login prompt'' (de quando é ligado até o login). Apenas
descobri esta pequena pérola depois que escrevi e submeti o documento
atual para o LDP.</P>

<DT><B>Scott Hankin</B><DD>
<P>For spotting a typo. ??</P>
</DL>
</P>


<H2><A NAME="ss14.5">14.5 Histórico de modificações</A>
</H2>

<H3>0.9 -> 0.9a (Novembro 2000)</H3>

<P>
<UL>
<LI>Adicionado o link ``roll your own os'' à seção Hardware.
</LI>
</UL>
</P>

<H3>0.8 -> 0.9 (Novembro 2000)</H3>

<P>
<UL>
<LI>Incorporada várias informações de Matthieu Peeters e John Fremlin em
daemons do kernel e o sistema de arquivos <CODE>/proc</CODE>.
</LI>
</UL>
</P>

<H3>0.7 -> 0.8 (Setembro 2000)</H3>

<P>
<UL>
<LI>Removidas as instruções sobre como construir um sistema, colocando-as
em um documento separado. Ajustado alguns links adequadamente.
</LI>
<LI>Movida a página web de 
<A HREF="http://learning.taslug.org.au/power2bash">learning@TasLUG</A>
para 
<A HREF="http://www.netspace.net.au/~gok/power2bash">meu próprio espaço na web</A>.
</LI>
<LI>Falhei completamente em incorporar um monte de bom material
contribuído por várias pessoas. Talvez da próxima vez :(
</LI>
</UL>
</P>

<H3>0.6 -> 0.7</H3>

<P>
<UL>
<LI>Mais ênfase nas explicações, menos em como construir um sistema,
informações de construção reunidas em uma seção separada e reduzida,
encaminhar os leitores para o ``Linux From Scratch'' de Gerard
Beekmans para construções sérias.
</LI>
<LI>Adicionada contribuições de David Leadbeater.
</LI>
<LI>Corrigido um par de urls, adicionado link para baixar o unios em
learning.taslug.org.au/resources.
</LI>
<LI>Testadas e corrigidas urls.
</LI>
<LI>Reescrita geral, posto em ordem.</LI>
</UL>
</P>

<H3>0.5 -> 0.6</H3>

<P>
<UL>
<LI>Adicionado o histórico de modificações.
</LI>
<LI>Adicionada várias tarefas a fazer.</LI>
</UL>
</P>


<H2><A NAME="ss14.6">14.6 TODO (Tarefas a fazer)</A>
</H2>

<P>
<UL>
<LI>Explicar módulos do kernel, depmod, modprobe, insmod e tudo mais (vou
precisar aprender primeiro!).
</LI>
<LI>Mencionar o sistema de arquivos /proc, potencial para exercícios.
</LI>
<LI>Converter para docbook sgml
</LI>
<LI>Adicionar mais exercícios, talvez uma seção inteira de grandes
exercícios, como criar um sistema de arquivos mínimo com arquivos da
instalação de uma distribuição.
</LI>
<LI>add makefile hack to bash build instructions - see easter notes. ??
</LI>
</UL>
</P>

</BODY>
</HTML>
